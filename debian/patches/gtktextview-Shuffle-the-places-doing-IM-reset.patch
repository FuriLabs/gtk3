From: Carlos Garnacho <carlosg@gnome.org>
Date: Thu, 18 Aug 2022 00:58:14 +0200
Subject: gtktextview: Shuffle the places doing IM reset

During text widget manipulation (inserting or deleting text via keyboard)
the IM context is reset somewhat early, before the actual change took place.
This makes IM lag behind in terms of surrounding text and cursor position.

Shuffle these IM reset calls so that they happen after the changes, and
ensure that the IM is actually reset, since that is currently toggled on
a pretty narrow set of circumstances.

Also, fix a bug during GtkEventControllerKey::im-update where the condition
on cursor position editability to reset the IM context was inverted.

Origin: upstream, 3.24.35, commit:0a8b0025e3102d2bd9977a011dfb884d36cfa1a5
---
 gtk/gtktextview.c | 29 ++++++++++++++++++++---------
 1 file changed, 20 insertions(+), 9 deletions(-)

diff --git a/gtk/gtktextview.c b/gtk/gtktextview.c
index 9651c4a..148f744 100644
--- a/gtk/gtktextview.c
+++ b/gtk/gtktextview.c
@@ -5513,7 +5513,7 @@ gtk_text_view_key_press_event (GtkWidget *widget, GdkEventKey *event)
   if (gtk_im_context_filter_keypress (priv->im_context, event))
     {
       priv->need_im_reset = TRUE;
-      if (!can_insert)
+      if (can_insert)
         gtk_text_view_reset_im_context (text_view);
       retval = TRUE;
     }
@@ -6564,8 +6564,6 @@ gtk_text_view_move_cursor (GtkTextView     *text_view,
       return;
     }
 
-  gtk_text_view_reset_im_context (text_view);
-
   if (step == GTK_MOVEMENT_PAGES)
     {
       if (!gtk_text_view_scroll_pages (text_view, count, extend_selection))
@@ -6749,6 +6747,9 @@ gtk_text_view_move_cursor (GtkTextView     *text_view,
 
   gtk_text_view_check_cursor_blink (text_view);
   gtk_text_view_pend_cursor_blink (text_view);
+
+  priv->need_im_reset = TRUE;
+  gtk_text_view_reset_im_context (text_view);
 }
 
 static void
@@ -7039,14 +7040,16 @@ gtk_text_view_delete_from_cursor (GtkTextView   *text_view,
 
   priv = text_view->priv;
 
-  gtk_text_view_reset_im_context (text_view);
-
   if (type == GTK_DELETE_CHARS)
     {
       /* Char delete deletes the selection, if one exists */
       if (gtk_text_buffer_delete_selection (get_buffer (text_view), TRUE,
                                             priv->editable))
-        return;
+        {
+          priv->need_im_reset = TRUE;
+          gtk_text_view_reset_im_context (text_view);
+          return;
+        }
     }
 
   gtk_text_buffer_get_iter_at_mark (get_buffer (text_view), &insert,
@@ -7173,6 +7176,9 @@ gtk_text_view_delete_from_cursor (GtkTextView   *text_view,
     {
       gtk_widget_error_bell (GTK_WIDGET (text_view));
     }
+
+  priv->need_im_reset = TRUE;
+  gtk_text_view_reset_im_context (text_view);
 }
 
 static void
@@ -7183,12 +7189,14 @@ gtk_text_view_backspace (GtkTextView *text_view)
 
   priv = text_view->priv;
 
-  gtk_text_view_reset_im_context (text_view);
-
   /* Backspace deletes the selection, if one exists */
   if (gtk_text_buffer_delete_selection (get_buffer (text_view), TRUE,
                                         priv->editable))
-    return;
+    {
+      priv->need_im_reset = TRUE;
+      gtk_text_view_reset_im_context (text_view);
+      return;
+    }
 
   gtk_text_buffer_get_iter_at_mark (get_buffer (text_view),
                                     &insert,
@@ -7201,6 +7209,9 @@ gtk_text_view_backspace (GtkTextView *text_view)
       DV(g_print (G_STRLOC": scrolling onscreen\n"));
       gtk_text_view_scroll_mark_onscreen (text_view,
                                           gtk_text_buffer_get_insert (get_buffer (text_view)));
+
+      priv->need_im_reset = TRUE;
+      gtk_text_view_reset_im_context (text_view);
     }
   else
     {
