From: Robert Mader <robert.mader@posteo.de>
Date: Sat, 27 Mar 2021 15:48:00 +0100
Subject: gdk/wayland: Defer processing of globals closures

... until all globals have been received.

The dependency tracking introduced in 4e9be39518 only allows to
specify required globals and processes the closures as soon as
the requirements have been met. There are, however, also optional
dependencies - most notably the primary_selection protocol.
Currently we rely on the fact that compositors like Mutter announce
it before `wl_seat`, even though the order is not specified in
the spec.

Process globals closures only after all globals have been announced,
so optional dependencies can be accommodated.

Bug: https://gitlab.gnome.org/GNOME/gtk/-/issues/3791
Origin: upstream, 3.24.29, commit:86ef0e6094bc3e76a79b382c873148931d4d5682
---
 gdk/wayland/gdkdisplay-wayland.c | 30 +++++++++++++-----------------
 1 file changed, 13 insertions(+), 17 deletions(-)

diff --git a/gdk/wayland/gdkdisplay-wayland.c b/gdk/wayland/gdkdisplay-wayland.c
index 7e924fd..fc5e408 100644
--- a/gdk/wayland/gdkdisplay-wayland.c
+++ b/gdk/wayland/gdkdisplay-wayland.c
@@ -434,26 +434,19 @@ gdk_registry_handle_global (void               *data,
     }
   else if (strcmp (interface, "wl_seat") == 0)
     {
+      SeatAddedClosure *closure;
       static const char *required_device_manager_globals[] = {
         "wl_compositor",
         "wl_data_device_manager",
         NULL
       };
 
-      if (has_required_globals (display_wayland,
-                                required_device_manager_globals))
-        _gdk_wayland_display_add_seat (display_wayland, id, version);
-      else
-        {
-          SeatAddedClosure *closure;
-
-          closure = g_new0 (SeatAddedClosure, 1);
-          closure->base.handler = seat_added_closure_run;
-          closure->base.required_globals = required_device_manager_globals;
-          closure->id = id;
-          closure->version = version;
-          postpone_on_globals_closure (display_wayland, &closure->base);
-        }
+      closure = g_new0 (SeatAddedClosure, 1);
+      closure->base.handler = seat_added_closure_run;
+      closure->base.required_globals = required_device_manager_globals;
+      closure->id = id;
+      closure->version = version;
+      postpone_on_globals_closure (display_wayland, &closure->base);
     }
   else if (strcmp (interface, "wl_data_device_manager") == 0)
     {
@@ -533,8 +526,6 @@ gdk_registry_handle_global (void               *data,
 
   g_hash_table_insert (display_wayland->known_globals,
                        GUINT_TO_POINTER (id), g_strdup (interface));
-
-  process_on_globals_closures (display_wayland);
 }
 
 static void
@@ -625,8 +616,13 @@ _gdk_wayland_display_open (const gchar *display_name)
 
   display_wayland->wl_registry = wl_display_get_registry (display_wayland->wl_display);
   wl_registry_add_listener (display_wayland->wl_registry, &registry_listener, display_wayland);
+  if (wl_display_roundtrip (display_wayland->wl_display) < 0)
+    {
+      g_object_unref (display);
+      return NULL;
+    }
 
-  _gdk_wayland_display_async_roundtrip (display_wayland);
+  process_on_globals_closures (display_wayland);
 
   /* Wait for initializing to complete. This means waiting for all
    * asynchrounous roundtrips that were triggered during initial roundtrip. */
