Description: Only load CSS image data when needed
Author: Benjamin Otte <otte@redhat.com>
Origin: upstream, http://git.gnome.org/browse/gtk+/commit/?id=6348ded15d44a7781b6eab7bbc6dfe972b9f87f5
Origin: upstream, http://git.gnome.org/browse/gtk+/commit/?id=18ca907c4cb37c234868ef13797f1a563fe01502
Origin: upstream, http://git.gnome.org/browse/gtk+/commit/?id=e3cd958e369395c45d18ba1a3673dfb2d5247d95
Origin: upstream, http://git.gnome.org/browse/gtk+/commit/?id=b2e1b1124f4b5a5fcf83474aa3eed8fda547c66a
Origin: upstream, http://git.gnome.org/browse/gtk+/commit/?id=e6b3cbe7d2c8ad23284bcf4a17f350043e3afb54
Bug: https://bugzilla.gnome.org/show_bug.cgi?id=692934
Last-Update: 2013-02-04

Index: b/gtk/Makefile.am
===================================================================
--- a/gtk/Makefile.am
+++ b/gtk/Makefile.am
@@ -443,6 +443,7 @@
 	gtkcssimagegradientprivate.h	\
 	gtkcssimagelinearprivate.h	\
 	gtkcssimageprivate.h	\
+	gtkcssimagesurfaceprivate.h	\
 	gtkcssimageurlprivate.h	\
 	gtkcssimagevalueprivate.h	\
 	gtkcssimagewin32private.h	\
@@ -665,6 +666,7 @@
 	gtkcssimagecrossfade.c	\
 	gtkcssimagegradient.c	\
 	gtkcssimagelinear.c	\
+	gtkcssimagesurface.c	\
 	gtkcssimageurl.c	\
 	gtkcssimagevalue.c	\
 	gtkcssimagewin32.c	\
Index: b/gtk/gtkcssimagesurface.c
===================================================================
--- /dev/null
+++ b/gtk/gtkcssimagesurface.c
@@ -0,0 +1,163 @@
+/*
+ * Copyright © 2011 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Authors: Benjamin Otte <otte@gnome.org>
+ */
+
+#include "config.h"
+
+#include "gtkcssimagesurfaceprivate.h"
+
+G_DEFINE_TYPE (GtkCssImageSurface, _gtk_css_image_surface, GTK_TYPE_CSS_IMAGE)
+
+static int
+gtk_css_image_surface_get_width (GtkCssImage *image)
+{
+  GtkCssImageSurface *surface = GTK_CSS_IMAGE_SURFACE (image);
+
+  return cairo_image_surface_get_width (surface->surface);
+}
+
+static int
+gtk_css_image_surface_get_height (GtkCssImage *image)
+{
+  GtkCssImageSurface *surface = GTK_CSS_IMAGE_SURFACE (image);
+
+  return cairo_image_surface_get_height (surface->surface);
+}
+
+static void
+gtk_css_image_surface_draw (GtkCssImage *image,
+                            cairo_t     *cr,
+                            double       width,
+                            double       height)
+{
+  GtkCssImageSurface *surface = GTK_CSS_IMAGE_SURFACE (image);
+
+  cairo_rectangle (cr, 0, 0, width, height);
+  cairo_scale (cr,
+               width / cairo_image_surface_get_width (surface->surface),
+               height / cairo_image_surface_get_height (surface->surface));
+  cairo_set_source_surface (cr, surface->surface, 0, 0);
+  cairo_pattern_set_extend (cairo_get_source (cr), CAIRO_EXTEND_PAD);
+  cairo_fill (cr);
+}
+
+static cairo_status_t
+surface_write (void                *closure,
+               const unsigned char *data,
+               unsigned int         length)
+{
+  g_byte_array_append (closure, data, length);
+
+  return CAIRO_STATUS_SUCCESS;
+}
+
+static void
+gtk_css_image_surface_print (GtkCssImage *image,
+                             GString     *string)
+{
+#if CAIRO_HAS_PNG_FUNCTIONS
+  GtkCssImageSurface *surface = GTK_CSS_IMAGE_SURFACE (image);
+  GByteArray *array;
+  char *base64;
+  
+  array = g_byte_array_new ();
+  cairo_surface_write_to_png_stream (surface->surface, surface_write, array);
+  base64 = g_base64_encode (array->data, array->len);
+  g_byte_array_free (array, TRUE);
+
+  g_string_append (string, "surface(\"data:image/png;base64,");
+  g_string_append (string, base64);
+  g_string_append (string, "\")");
+
+  g_free (base64);
+#else
+  g_string_append (string, "none /* you need cairo png functions enabled to make this work */");
+#endif
+}
+
+static void
+gtk_css_image_surface_dispose (GObject *object)
+{
+  GtkCssImageSurface *surface = GTK_CSS_IMAGE_SURFACE (object);
+
+  if (surface->surface)
+    {
+      cairo_surface_destroy (surface->surface);
+      surface->surface = NULL;
+    }
+
+  G_OBJECT_CLASS (_gtk_css_image_surface_parent_class)->dispose (object);
+}
+
+static void
+_gtk_css_image_surface_class_init (GtkCssImageSurfaceClass *klass)
+{
+  GtkCssImageClass *image_class = GTK_CSS_IMAGE_CLASS (klass);
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  image_class->get_width = gtk_css_image_surface_get_width;
+  image_class->get_height = gtk_css_image_surface_get_height;
+  image_class->draw = gtk_css_image_surface_draw;
+  image_class->print = gtk_css_image_surface_print;
+
+  object_class->dispose = gtk_css_image_surface_dispose;
+}
+
+static void
+_gtk_css_image_surface_init (GtkCssImageSurface *image_surface)
+{
+}
+
+GtkCssImage *
+_gtk_css_image_surface_new (cairo_surface_t *surface)
+{
+  GtkCssImage *image;
+
+  g_return_val_if_fail (surface != NULL, NULL);
+
+  image = g_object_new (GTK_TYPE_CSS_IMAGE_SURFACE, NULL);
+  
+  GTK_CSS_IMAGE_SURFACE (image)->surface = cairo_surface_reference (surface);
+
+  return image;
+}
+
+GtkCssImage *
+_gtk_css_image_surface_new_for_pixbuf (GdkPixbuf *pixbuf)
+{
+  GtkCssImage *image;
+  cairo_surface_t *surface;
+  cairo_t *cr;
+
+  g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
+
+  surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
+                                        gdk_pixbuf_get_width (pixbuf),
+                                        gdk_pixbuf_get_height (pixbuf));
+  cr = cairo_create (surface);
+  gdk_cairo_set_source_pixbuf (cr, pixbuf, 0, 0);
+  cairo_paint (cr);
+  cairo_destroy (cr);
+
+  image = _gtk_css_image_surface_new (surface);
+
+  cairo_surface_destroy (surface);
+
+  return image;
+}
+
Index: b/gtk/gtkcssimagesurfaceprivate.h
===================================================================
--- /dev/null
+++ b/gtk/gtkcssimagesurfaceprivate.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright © 2011 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Authors: Benjamin Otte <otte@gnome.org>
+ */
+
+#ifndef __GTK_CSS_IMAGE_SURFACE_PRIVATE_H__
+#define __GTK_CSS_IMAGE_SURFACE_PRIVATE_H__
+
+#include "gtk/gtkcssimageprivate.h"
+
+G_BEGIN_DECLS
+
+#define GTK_TYPE_CSS_IMAGE_SURFACE           (_gtk_css_image_surface_get_type ())
+#define GTK_CSS_IMAGE_SURFACE(obj)           (G_TYPE_CHECK_INSTANCE_CAST (obj, GTK_TYPE_CSS_IMAGE_SURFACE, GtkCssImageSurface))
+#define GTK_CSS_IMAGE_SURFACE_CLASS(cls)     (G_TYPE_CHECK_CLASS_CAST (cls, GTK_TYPE_CSS_IMAGE_SURFACE, GtkCssImageSurfaceClass))
+#define GTK_IS_CSS_IMAGE_SURFACE(obj)        (G_TYPE_CHECK_INSTANCE_TYPE (obj, GTK_TYPE_CSS_IMAGE_SURFACE))
+#define GTK_IS_CSS_IMAGE_SURFACE_CLASS(obj)  (G_TYPE_CHECK_CLASS_TYPE (obj, GTK_TYPE_CSS_IMAGE_SURFACE))
+#define GTK_CSS_IMAGE_SURFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_CSS_IMAGE_SURFACE, GtkCssImageSurfaceClass))
+
+typedef struct _GtkCssImageSurface           GtkCssImageSurface;
+typedef struct _GtkCssImageSurfaceClass      GtkCssImageSurfaceClass;
+
+struct _GtkCssImageSurface
+{
+  GtkCssImage parent;
+
+  cairo_surface_t *surface;             /* the surface we render - guaranteed to be an image surface */
+};
+
+struct _GtkCssImageSurfaceClass
+{
+  GtkCssImageClass parent_class;
+};
+
+GType          _gtk_css_image_surface_get_type             (void) G_GNUC_CONST;
+
+GtkCssImage *  _gtk_css_image_surface_new                  (cairo_surface_t *surface);
+GtkCssImage *  _gtk_css_image_surface_new_for_pixbuf       (GdkPixbuf       *pixbuf);
+
+G_END_DECLS
+
+#endif /* __GTK_CSS_IMAGE_SURFACE_PRIVATE_H__ */
Index: b/gtk/gtkcssimageurl.c
===================================================================
--- a/gtk/gtkcssimageurl.c
+++ b/gtk/gtkcssimageurl.c
@@ -22,17 +22,71 @@
 #include <string.h>
 
 #include "gtkcssimageurlprivate.h"
-
-#include "gtkcssprovider.h"
+#include "gtkcssimagesurfaceprivate.h"
 
 G_DEFINE_TYPE (GtkCssImageUrl, _gtk_css_image_url, GTK_TYPE_CSS_IMAGE)
 
+static GtkCssImage *
+gtk_css_image_url_load_image (GtkCssImageUrl *url)
+{
+  GdkPixbuf *pixbuf;
+  GError *error = NULL;
+  GFileInputStream *input;
+
+  if (url->loaded_image)
+    return url->loaded_image;
+
+  /* We special case resources here so we can use
+     gdk_pixbuf_new_from_resource, which in turn has some special casing
+     for GdkPixdata files to avoid duplicating the memory for the pixbufs */
+  if (g_file_has_uri_scheme (url->file, "resource"))
+    {
+      char *uri = g_file_get_uri (url->file);
+      char *resource_path = g_uri_unescape_string (uri + strlen ("resource://"), NULL);
+
+      pixbuf = gdk_pixbuf_new_from_resource (resource_path, &error);
+      g_free (resource_path);
+      g_free (uri);
+    }
+  else
+    {
+      input = g_file_read (url->file, NULL, &error);
+      if (input != NULL)
+	{
+          pixbuf = gdk_pixbuf_new_from_stream (G_INPUT_STREAM (input), NULL, &error);
+          g_object_unref (input);
+	}
+      else
+        {
+          pixbuf = NULL;
+        }
+    }
+
+  if (pixbuf == NULL)
+    {
+      cairo_surface_t *empty = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 0, 0);
+
+      /* XXX: Can we get the error somehow sent to the CssProvider?
+       * I don't like just dumping it to stderr or losing it completely. */
+      g_warning ("Error loading image: %s", error->message);
+      g_error_free (error);
+      url->loaded_image = _gtk_css_image_surface_new (empty);
+      cairo_surface_destroy (empty);
+      return url->loaded_image; 
+    }
+
+  url->loaded_image = _gtk_css_image_surface_new_for_pixbuf (pixbuf);
+  g_object_unref (pixbuf);
+
+  return url->loaded_image;
+}
+
 static int
 gtk_css_image_url_get_width (GtkCssImage *image)
 {
   GtkCssImageUrl *url = GTK_CSS_IMAGE_URL (image);
 
-  return cairo_image_surface_get_width (url->surface);
+  return _gtk_css_image_get_width (gtk_css_image_url_load_image (url));
 }
 
 static int
@@ -40,7 +94,15 @@
 {
   GtkCssImageUrl *url = GTK_CSS_IMAGE_URL (image);
 
-  return cairo_image_surface_get_height (url->surface);
+  return _gtk_css_image_get_height (gtk_css_image_url_load_image (url));
+}
+
+static double
+gtk_css_image_url_get_aspect_ratio (GtkCssImage *image)
+{
+  GtkCssImageUrl *url = GTK_CSS_IMAGE_URL (image);
+
+  return _gtk_css_image_get_aspect_ratio (gtk_css_image_url_load_image (url));
 }
 
 static void
@@ -51,13 +113,20 @@
 {
   GtkCssImageUrl *url = GTK_CSS_IMAGE_URL (image);
 
-  cairo_rectangle (cr, 0, 0, width, height);
-  cairo_scale (cr,
-               width / cairo_image_surface_get_width (url->surface),
-               height / cairo_image_surface_get_height (url->surface));
-  cairo_set_source_surface (cr, url->surface, 0, 0);
-  cairo_pattern_set_extend (cairo_get_source (cr), CAIRO_EXTEND_PAD);
-  cairo_fill (cr);
+  _gtk_css_image_draw (gtk_css_image_url_load_image (url), cr, width, height);
+}
+
+static GtkCssImage *
+gtk_css_image_url_compute (GtkCssImage             *image,
+                           guint                    property_id,
+                           GtkStyleProviderPrivate *provider,
+                           GtkCssComputedValues    *values,
+                           GtkCssComputedValues    *parent_values,
+                           GtkCssDependencies      *dependencies)
+{
+  GtkCssImageUrl *url = GTK_CSS_IMAGE_URL (image);
+
+  return g_object_ref (gtk_css_image_url_load_image (url));
 }
 
 static gboolean
@@ -65,92 +134,21 @@
                          GtkCssParser *parser)
 {
   GtkCssImageUrl *url = GTK_CSS_IMAGE_URL (image);
-  GdkPixbuf *pixbuf;
-  GFile *file;
-  cairo_t *cr;
-  GError *error = NULL;
-  GFileInputStream *input;
 
-  file = _gtk_css_parser_read_url (parser);
-  if (file == NULL)
+  url->file = _gtk_css_parser_read_url (parser);
+  if (url->file == NULL)
     return FALSE;
 
-  /* We special case resources here so we can use
-     gdk_pixbuf_new_from_resource, which in turn has some special casing
-     for GdkPixdata files to avoid duplicating the memory for the pixbufs */
-  if (g_file_has_uri_scheme (file, "resource"))
-    {
-      char *uri = g_file_get_uri (file);
-      char *resource_path = g_uri_unescape_string (uri + strlen ("resource://"), NULL);
-
-      pixbuf = gdk_pixbuf_new_from_resource (resource_path, &error);
-      g_free (resource_path);
-      g_free (uri);
-    }
-  else
-    {
-      input = g_file_read (file, NULL, &error);
-      if (input == NULL)
-	{
-	  _gtk_css_parser_take_error (parser, error);
-	  return FALSE;
-	}
-
-      pixbuf = gdk_pixbuf_new_from_stream (G_INPUT_STREAM (input), NULL, &error);
-      g_object_unref (input);
-    }
-  g_object_unref (file);
-
-  if (pixbuf == NULL)
-    {
-      _gtk_css_parser_take_error (parser, error);
-      return FALSE;
-    }
-
-  url->surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
-                                             gdk_pixbuf_get_width (pixbuf),
-                                             gdk_pixbuf_get_height (pixbuf));
-  cr = cairo_create (url->surface);
-  gdk_cairo_set_source_pixbuf (cr, pixbuf, 0, 0);
-  cairo_paint (cr);
-  cairo_destroy (cr);
-  g_object_unref (pixbuf);
-
   return TRUE;
 }
 
-static cairo_status_t
-surface_write (void                *closure,
-               const unsigned char *data,
-               unsigned int         length)
-{
-  g_byte_array_append (closure, data, length);
-
-  return CAIRO_STATUS_SUCCESS;
-}
-
 static void
 gtk_css_image_url_print (GtkCssImage *image,
                          GString     *string)
 {
-#if CAIRO_HAS_PNG_FUNCTIONS
   GtkCssImageUrl *url = GTK_CSS_IMAGE_URL (image);
-  GByteArray *array;
-  char *base64;
-  
-  array = g_byte_array_new ();
-  cairo_surface_write_to_png_stream (url->surface, surface_write, array);
-  base64 = g_base64_encode (array->data, array->len);
-  g_byte_array_free (array, TRUE);
-
-  g_string_append (string, "url(\"data:image/png;base64,");
-  g_string_append (string, base64);
-  g_string_append (string, "\")");
-
-  g_free (base64);
-#else
-  g_string_append (string, "none /* you need cairo png functions enabled to make this work */");
-#endif
+
+  _gtk_css_image_print (gtk_css_image_url_load_image (url), string);
 }
 
 static void
@@ -158,11 +156,8 @@
 {
   GtkCssImageUrl *url = GTK_CSS_IMAGE_URL (object);
 
-  if (url->surface)
-    {
-      cairo_surface_destroy (url->surface);
-      url->surface = NULL;
-    }
+  g_clear_object (&url->file);
+  g_clear_object (&url->loaded_image);
 
   G_OBJECT_CLASS (_gtk_css_image_url_parent_class)->dispose (object);
 }
@@ -175,6 +170,8 @@
 
   image_class->get_width = gtk_css_image_url_get_width;
   image_class->get_height = gtk_css_image_url_get_height;
+  image_class->get_aspect_ratio = gtk_css_image_url_get_aspect_ratio;
+  image_class->compute = gtk_css_image_url_compute;
   image_class->draw = gtk_css_image_url_draw;
   image_class->parse = gtk_css_image_url_parse;
   image_class->print = gtk_css_image_url_print;
Index: b/gtk/gtkcssimageurlprivate.h
===================================================================
--- a/gtk/gtkcssimageurlprivate.h
+++ b/gtk/gtkcssimageurlprivate.h
@@ -38,7 +38,8 @@
 {
   GtkCssImage parent;
 
-  cairo_surface_t *surface;             /* the surface we render - guaranteed to be an image surface */
+  GFile           *file;                /* the file we're loading from */
+  GtkCssImage     *loaded_image;        /* the actual image we render */
 };
 
 struct _GtkCssImageUrlClass
