From 70ffd98af2e290ebda8043f0fa9b0817e99ced2f Mon Sep 17 00:00:00 2001
From: William Hua <william.hua@canonical.com>
Date: Tue, 19 May 2015 17:58:38 -0500
Subject: [PATCH 2/2] Unstable mir patches from git wip/mir-unstable.

---
 gdk/mir/gdkmir-debug.c      |  18 +++
 gdk/mir/gdkmir-private.h    |  12 --
 gdk/mir/gdkmireventsource.c |  97 ++------------
 gdk/mir/gdkmirwindowimpl.c  | 319 ++++++++++++--------------------------------
 4 files changed, 116 insertions(+), 330 deletions(-)

diff --git a/gdk/mir/gdkmir-debug.c b/gdk/mir/gdkmir-debug.c
index 9bfdfe7..a135f1b 100644
--- a/gdk/mir/gdkmir-debug.c
+++ b/gdk/mir/gdkmir-debug.c
@@ -184,8 +184,26 @@ _gdk_mir_print_close_event (const MirCloseSurfaceEvent *event)
 void
 _gdk_mir_print_event (const MirEvent *event)
 {
+  const MirInputEvent *input_event;
+
   switch (mir_event_get_type (event))
     {
+    case mir_event_type_input:
+      input_event = mir_event_get_input_event (event);
+
+      switch (mir_input_event_get_type (input_event))
+        {
+          case mir_input_event_type_key:
+            _gdk_mir_print_key_event (mir_event_get_input_event (event));
+            break;
+          case mir_input_event_type_touch:
+            _gdk_mir_print_motion_event (mir_event_get_input_event (event));
+            break;
+          case mir_input_event_type_pointer:
+            _gdk_mir_print_motion_event (mir_event_get_input_event (event));
+            break;
+        }
+      break;
     case mir_event_type_key:
       _gdk_mir_print_key_event (mir_event_get_input_event (event));
       break;
diff --git a/gdk/mir/gdkmir-private.h b/gdk/mir/gdkmir-private.h
index 847720b..2464434 100644
--- a/gdk/mir/gdkmir-private.h
+++ b/gdk/mir/gdkmir-private.h
@@ -133,16 +133,4 @@ void _gdk_mir_print_resize_event (const MirResizeEvent *event);
 
 void _gdk_mir_print_event (const MirEvent *event);
 
-/* TODO: Remove once we have proper transient window support. */
-GdkWindow * _gdk_mir_window_get_visible_transient_child (GdkWindow *window,
-                                                         gdouble    x,
-                                                         gdouble    y,
-                                                         gdouble   *out_x,
-                                                         gdouble   *out_y);
-
-/* TODO: Remove once we have proper transient window support. */
-void _gdk_mir_window_transient_children_foreach (GdkWindow  *window,
-                                                 void      (*func) (GdkWindow *, gpointer),
-                                                 gpointer    user_data);
-
 #endif /* __GDK_PRIVATE_MIR_H__ */
diff --git a/gdk/mir/gdkmireventsource.c b/gdk/mir/gdkmireventsource.c
index aed881c..41a4422 100644
--- a/gdk/mir/gdkmireventsource.c
+++ b/gdk/mir/gdkmireventsource.c
@@ -148,6 +148,8 @@ generate_button_event (GdkWindow *window, GdkEventType type, gdouble x, gdouble
 {
   GdkEvent *event;
 
+  g_print ("%s %lf %lf\n", G_STRFUNC, x, y);
+
   event = gdk_event_new (type);
   event->button.x = x;
   event->button.y = y;
@@ -308,47 +310,6 @@ handle_key_event (GdkWindow *window, const MirInputEvent *event)
     }
 }
 
-/* TODO: Remove once we have proper transient window support. */
-typedef struct
-{
-  GdkWindow *except;
-  gdouble    x;
-  gdouble    y;
-  guint32    time;
-} LeaveInfo;
-
-/* TODO: Remove once we have proper transient window support. */
-/*
- * leave_windows_except:
- *
- * Generate a leave event for every window except the one the cursor is in.
- */
-static void
-leave_windows_except (GdkWindow *window,
-                      gpointer   user_data)
-{
-  LeaveInfo info = *((LeaveInfo *) user_data);
-
-  info.x -= window->x;
-  info.y -= window->y;
-
-  _gdk_mir_window_transient_children_foreach (window, leave_windows_except, &info);
-
-  if (window != info.except)
-    {
-      GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
-      gboolean cursor_inside;
-      guint button_state;
-
-      _gdk_mir_window_impl_get_cursor_state (impl, NULL, NULL, &cursor_inside, &button_state);
-
-      if (cursor_inside)
-        generate_crossing_event (window, GDK_LEAVE_NOTIFY, info.x, info.y, info.time);
-
-      _gdk_mir_window_impl_set_cursor_state (impl, info.x, info.y, FALSE, button_state);
-    }
-}
-
 static guint
 mir_pointer_event_get_button_state (const MirPointerEvent *event)
 {
@@ -388,49 +349,6 @@ handle_motion_event (GdkWindow *window, const MirInputEvent *event)
   modifier_state = get_modifier_state (mir_pointer_event_modifiers (pointer_event), mir_pointer_event_get_button_state (pointer_event));
   event_time = NANO_TO_MILLI (mir_input_event_get_event_time (event));
 
-  /* TODO: Remove once we have proper transient window support. */
-  if (mir_pointer_event_action (pointer_event) == mir_pointer_action_leave)
-    {
-      LeaveInfo info;
-
-      info.x = x;
-      info.y = y;
-      info.time = event_time;
-      info.except = window;
-
-      /* Leave all transient children from leaf to root, except the root since we do it later. */
-      _gdk_mir_window_transient_children_foreach (window, leave_windows_except, &info);
-    }
-  else
-    {
-      LeaveInfo info;
-
-      info.x = x;
-      info.y = y;
-      info.time = event_time;
-      info.except = _gdk_mir_window_get_visible_transient_child (window, x, y, &x, &y);
-
-      /* Leave all transient children from leaf to root, except the pointer window since we enter it. */
-      _gdk_mir_window_transient_children_foreach (window, leave_windows_except, &info);
-
-      window = info.except;
-
-      if (window)
-        {
-          /* Enter the pointer window. */
-          gboolean cursor_inside_pointer_window;
-
-          impl = GDK_MIR_WINDOW_IMPL (window->impl);
-          _gdk_mir_window_impl_get_cursor_state (impl, NULL, NULL, &cursor_inside_pointer_window, NULL);
-
-          if (!cursor_inside_pointer_window)
-            {
-              generate_crossing_event (window, GDK_ENTER_NOTIFY, x, y, event_time);
-              _gdk_mir_window_impl_set_cursor_state (impl, x, y, TRUE, mir_pointer_event_get_button_state (pointer_event));
-            }
-        }
-    }
-
   if (window)
     {
       gdouble new_x;
@@ -444,6 +362,8 @@ handle_motion_event (GdkWindow *window, const MirInputEvent *event)
         {
         case mir_pointer_action_button_up:
         case mir_pointer_action_button_down:
+          g_print ("%s button up/down\n", G_STRFUNC);
+
           event_type = mir_pointer_event_action (pointer_event) == mir_pointer_action_button_down ? GDK_BUTTON_PRESS : GDK_BUTTON_RELEASE;
           changed_button_state = button_state ^ mir_pointer_event_get_button_state (pointer_event);
           if (changed_button_state == 0 || (changed_button_state & mir_pointer_button_primary) != 0)
@@ -463,7 +383,11 @@ handle_motion_event (GdkWindow *window, const MirInputEvent *event)
           if (hscroll > 0.5 || vscroll > 0.5)
             generate_scroll_event (window, x, y, hscroll, vscroll, modifier_state, event_time);
           if (ABS (new_x - x) > 0.5 || ABS (new_y - y) > 0.5)
-            generate_motion_event (window, new_x, new_y, modifier_state, event_time);
+            {
+              generate_motion_event (window, new_x, new_y, modifier_state, event_time);
+              x = new_x;
+              y = new_y;
+            }
 
           break;
         case mir_pointer_action_leave:
@@ -616,6 +540,7 @@ static void
 gdk_mir_queued_event_free (GdkMirQueuedEvent *event)
 {
   _gdk_mir_window_reference_unref (event->window_ref);
+  mir_event_unref (event->event);
   g_slice_free (GdkMirQueuedEvent, event);
 }
 
@@ -800,7 +725,7 @@ _gdk_mir_event_source_queue (GdkMirWindowReference *window_ref,
   queued_event = g_slice_new (GdkMirQueuedEvent);
   g_atomic_int_inc (&window_ref->ref_count);
   queued_event->window_ref = window_ref;
-  queued_event->event = event;
+  queued_event->event = mir_event_ref (event);
 
   g_mutex_lock (&source->mir_event_lock);
   g_queue_push_tail (&source->mir_events, queued_event);
diff --git a/gdk/mir/gdkmirwindowimpl.c b/gdk/mir/gdkmirwindowimpl.c
index 9cafcc9..d150d3e 100644
--- a/gdk/mir/gdkmirwindowimpl.c
+++ b/gdk/mir/gdkmirwindowimpl.c
@@ -46,11 +46,8 @@ struct _GdkMirWindowImpl
   gint transient_x;
   gint transient_y;
 
-  /* Child windows (e.g. tooltips) */
-  GList *transient_children;
-
   /* Desired surface attributes */
-  MirSurfaceType surface_type;
+  GdkWindowTypeHint type_hint;
   MirSurfaceState surface_state;
 
   /* Pattern for background */
@@ -103,9 +100,9 @@ _gdk_mir_window_impl_set_surface_state (GdkMirWindowImpl *impl, MirSurfaceState
 }
 
 void
-_gdk_mir_window_impl_set_surface_type (GdkMirWindowImpl *impl, MirSurfaceType type)
+_gdk_mir_window_impl_set_surface_type (GdkMirWindowImpl *impl,
+                                       MirSurfaceType    type)
 {
-  impl->surface_type = type;
 }
 
 void
@@ -141,7 +138,7 @@ _gdk_mir_window_impl_get_cursor_state (GdkMirWindowImpl *impl,
 static void
 gdk_mir_window_impl_init (GdkMirWindowImpl *impl)
 {
-  impl->surface_type = mir_surface_type_normal;
+  impl->type_hint = GDK_WINDOW_TYPE_HINT_NORMAL;
   impl->surface_state = mir_surface_state_unknown;
 }
 
@@ -158,18 +155,6 @@ set_surface_state (GdkMirWindowImpl *impl,
 }
 
 static void
-set_surface_type (GdkMirWindowImpl *impl,
-                  MirSurfaceType type)
-{
-  if (impl->surface_type == type)
-    return;
-
-  impl->surface_type = type;
-  if (impl->surface)
-    mir_surface_set_type (impl->surface, type);
-}
-
-static void
 event_cb (MirSurface     *surface,
           const MirEvent *event,
           void           *context)
@@ -179,18 +164,87 @@ event_cb (MirSurface     *surface,
 
 static MirSurface *
 create_mir_surface (GdkDisplay *display,
+                    GdkWindow *parent,
+                    gint x,
+                    gint y,
                     gint width,
                     gint height,
+                    GdkWindowTypeHint type,
                     MirBufferUsage buffer_usage)
 {
+  GdkMirWindowImpl *parent_impl;
   MirSurfaceSpec *spec;
   MirConnection *connection;
   MirPixelFormat format;
   MirSurface *surface;
+  MirRectangle rect;
 
   connection = gdk_mir_display_get_mir_connection (display);
   format = _gdk_mir_display_get_pixel_format (display, buffer_usage);
-  spec = mir_connection_create_spec_for_normal_surface (connection, width, height, format);
+
+  if (parent)
+    parent_impl = GDK_MIR_WINDOW_IMPL (parent->impl);
+  else
+    parent_impl = NULL;
+
+  switch (type)
+    {
+      case GDK_WINDOW_TYPE_HINT_DIALOG:
+      case GDK_WINDOW_TYPE_HINT_DOCK:
+        spec = mir_connection_create_spec_for_dialog (connection,
+                                                      width,
+                                                      height,
+                                                      format);
+        break;
+      case GDK_WINDOW_TYPE_HINT_MENU:
+      case GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU:
+      case GDK_WINDOW_TYPE_HINT_POPUP_MENU:
+      case GDK_WINDOW_TYPE_HINT_TOOLBAR:
+      case GDK_WINDOW_TYPE_HINT_COMBO:
+        rect.left = x;
+        rect.top = y;
+        rect.width = 1;
+        rect.height = 1;
+        spec = mir_connection_create_spec_for_menu (connection,
+                                                    width,
+                                                    height,
+                                                    format,
+                                                    parent_impl ? parent_impl->surface : NULL,
+                                                    &rect,
+                                                    mir_edge_attachment_any);
+        break;
+      case GDK_WINDOW_TYPE_HINT_SPLASHSCREEN:
+      case GDK_WINDOW_TYPE_HINT_UTILITY:
+        spec = mir_connection_create_spec_for_modal_dialog (connection,
+                                                            width,
+                                                            height,
+                                                            format,
+                                                            parent_impl ? parent_impl->surface : NULL);
+        break;
+      case GDK_WINDOW_TYPE_HINT_DND:
+      case GDK_WINDOW_TYPE_HINT_TOOLTIP:
+      case GDK_WINDOW_TYPE_HINT_NOTIFICATION:
+        rect.left = x;
+        rect.top = y;
+        rect.width = 1;
+        rect.height = 1;
+        spec = mir_connection_create_spec_for_tooltip (connection,
+                                                       width,
+                                                       height,
+                                                       format,
+                                                       parent_impl ? parent_impl->surface : NULL,
+                                                       &rect);
+        break;
+      case GDK_WINDOW_TYPE_HINT_NORMAL:
+      case GDK_WINDOW_TYPE_HINT_DESKTOP:
+      default:
+        spec = mir_connection_create_spec_for_normal_surface (connection,
+                                                              width,
+                                                              height,
+                                                              format);
+        break;
+    }
+
   mir_surface_spec_set_name (spec, g_get_prgname ());
   mir_surface_spec_set_buffer_usage (spec, buffer_usage);
   surface = mir_surface_create_sync (spec);
@@ -199,15 +253,6 @@ create_mir_surface (GdkDisplay *display,
   return surface;
 }
 
-/* TODO: Remove once we have proper transient window support. */
-static gboolean
-should_render_in_parent (GdkWindow *window)
-{
-  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
-
-  return impl->transient_for && gdk_window_get_window_type (window) != GDK_WINDOW_TOPLEVEL;
-}
-
 static void
 ensure_surface_full (GdkWindow *window,
                      MirBufferUsage buffer_usage)
@@ -215,7 +260,7 @@ ensure_surface_full (GdkWindow *window,
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
   GdkMirWindowReference *window_ref;
 
-  if (impl->surface || should_render_in_parent (window))
+  if (impl->surface)
     return;
 
   /* no destroy notify -- we must leak for now
@@ -223,8 +268,10 @@ ensure_surface_full (GdkWindow *window,
    */
   window_ref = _gdk_mir_event_source_get_window_reference (window);
 
-  impl->surface = create_mir_surface (gdk_window_get_display (window),
+  impl->surface = create_mir_surface (gdk_window_get_display (window), impl->transient_for,
+                                      impl->transient_x, impl->transient_y,
                                       window->width, window->height,
+                                      impl->type_hint,
                                       buffer_usage);
 
   /* FIXME: can't make an initial resize event */
@@ -242,8 +289,6 @@ ensure_surface_full (GdkWindow *window,
   */
 
   mir_surface_set_event_handler (impl->surface, event_cb, window_ref); // FIXME: Ignore some events until shown
-  set_surface_type (impl, impl->surface_type);
-  set_surface_state (impl, impl->surface_state);
 }
 
 static void
@@ -289,56 +334,10 @@ ensure_no_surface (GdkWindow *window)
 }
 
 static void
-redraw_transient (GdkWindow *window)
-{
-  GdkRectangle r;
-  r.x = window->x;
-  r.y = window->y;
-  r.width = window->width;
-  r.height = window->height;
-  gdk_window_invalidate_rect (GDK_MIR_WINDOW_IMPL (window->impl)->transient_for, &r, FALSE);
-}
-
-static void
 send_buffer (GdkWindow *window)
 {
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
 
-  /* Transient windows draw onto parent instead */
-  if (should_render_in_parent (window))
-    {
-      redraw_transient (window);
-      return;
-    }
-
-  /* Composite transient windows over this one */
-  if (impl->transient_children)
-    {
-      cairo_surface_t *surface;
-      cairo_t *c;
-      GList *link;
-
-      surface = gdk_mir_window_impl_ref_cairo_surface (window);
-      c = cairo_create (surface);
-
-      for (link = impl->transient_children; link; link = link->next)
-        {
-          GdkWindow *child_window = link->data;
-          GdkMirWindowImpl *child_impl = GDK_MIR_WINDOW_IMPL (child_window->impl);
-
-          /* Skip children not yet drawn to */
-          if (!child_impl->cairo_surface)
-            continue;
-
-          cairo_set_source_surface (c, child_impl->cairo_surface, child_window->x, child_window->y);
-          cairo_rectangle (c, child_window->x, child_window->y, child_window->width, child_window->height);
-          cairo_fill (c);
-        }
-
-      cairo_destroy (c);
-      cairo_surface_destroy (surface);
-    }
-
   /* Send the completed buffer to Mir */
   mir_surface_swap_buffers_sync (impl->surface);
 
@@ -363,7 +362,7 @@ gdk_mir_window_impl_ref_cairo_surface (GdkWindow *window)
     }
 
   /* Transient windows get rendered into a buffer and copied onto their parent */
-  if (should_render_in_parent (window) || window->gl_paint_context)
+  if (window->gl_paint_context)
     {
       cairo_surface = cairo_image_surface_create (pixel_format, window->width, window->height);
     }
@@ -409,13 +408,6 @@ static void
 gdk_mir_window_impl_finalize (GObject *object)
 {
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (object);
-  GList *link;
-
-  for (link = impl->transient_children; link; link = link->next)
-    {
-      GdkWindow *window = link->data;
-      gdk_window_destroy (window);
-    }
 
   if (impl->background)
     cairo_pattern_destroy (impl->background);
@@ -423,7 +415,6 @@ gdk_mir_window_impl_finalize (GObject *object)
     mir_surface_release_sync (impl->surface);
   if (impl->cairo_surface)
     cairo_surface_destroy (impl->cairo_surface);
-  g_list_free (impl->transient_children);
 
   G_OBJECT_CLASS (gdk_mir_window_impl_parent_class)->finalize (object);
 }
@@ -460,9 +451,6 @@ gdk_mir_window_impl_hide (GdkWindow *window)
   impl->cursor_inside = FALSE;
   impl->visible = FALSE;
   ensure_no_surface (window);
-
-  if (should_render_in_parent (window))
-    redraw_transient (window);
 }
 
 static void
@@ -474,9 +462,6 @@ gdk_mir_window_impl_withdraw (GdkWindow *window)
   impl->cursor_inside = FALSE;
   impl->visible = FALSE;
   ensure_no_surface (window);
-
-  if (should_render_in_parent (window))
-    redraw_transient (window);
 }
 
 static void
@@ -530,19 +515,10 @@ gdk_mir_window_impl_move_resize (GdkWindow *window,
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
   gboolean recreate_surface = FALSE;
 
-  /* Redraw parent where we moved from */
-  if (should_render_in_parent (window))
-    redraw_transient (window);
-
   /* Transient windows can move wherever they want */
   if (with_move)
     {
-      if (should_render_in_parent (window))
-        {
-          window->x = x;
-          window->y = y;
-        }
-      else if (x != impl->transient_x || y != impl->transient_y)
+      if (x != impl->transient_x || y != impl->transient_y)
         {
           impl->transient_x = x;
           impl->transient_y = y;
@@ -564,10 +540,6 @@ gdk_mir_window_impl_move_resize (GdkWindow *window,
       ensure_no_surface (window);
       ensure_surface (window);
     }
-
-  /* Redraw parent where we moved to */
-  if (should_render_in_parent (window))
-    redraw_transient (window);
 }
 
 static void
@@ -742,16 +714,6 @@ gdk_mir_window_impl_destroy (GdkWindow *window,
 
   impl->visible = FALSE;
   ensure_no_surface (window);
-
-  if (should_render_in_parent (window))
-    {
-      /* Redraw parent */
-      redraw_transient (window);
-
-      /* Remove from transient list */
-      GdkMirWindowImpl *parent_impl = GDK_MIR_WINDOW_IMPL (impl->transient_for->impl);
-      parent_impl->transient_children = g_list_remove (parent_impl->transient_children, window);
-    }
 }
 
 static void
@@ -771,41 +733,13 @@ static void
 gdk_mir_window_impl_set_type_hint (GdkWindow         *window,
                                    GdkWindowTypeHint  hint)
 {
-  MirSurfaceType mir_type = mir_surface_type_normal;
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
 
-  switch (hint)
+  if (hint != impl->type_hint)
     {
-      case GDK_WINDOW_TYPE_HINT_NORMAL:
-      case GDK_WINDOW_TYPE_HINT_DOCK:
-      case GDK_WINDOW_TYPE_HINT_DESKTOP:
-        mir_type = mir_surface_type_normal;
-        break;
-      case GDK_WINDOW_TYPE_HINT_DIALOG:
-        mir_type = mir_surface_type_dialog;
-        break;
-      case GDK_WINDOW_TYPE_HINT_UTILITY:
-        mir_type = mir_surface_type_utility;
-        break;
-      case GDK_WINDOW_TYPE_HINT_MENU:
-      case GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU:
-      case GDK_WINDOW_TYPE_HINT_POPUP_MENU:
-      case GDK_WINDOW_TYPE_HINT_COMBO:
-        mir_type = mir_surface_type_menu;
-        break;
-      case GDK_WINDOW_TYPE_HINT_TOOLTIP:
-        mir_type = mir_surface_type_tip;
-        break;
-      case GDK_WINDOW_TYPE_HINT_SPLASHSCREEN:
-      case GDK_WINDOW_TYPE_HINT_DND:
-      case GDK_WINDOW_TYPE_HINT_NOTIFICATION:
-        mir_type = mir_surface_type_overlay;
-        break;
-      case GDK_WINDOW_TYPE_HINT_TOOLBAR:
-        mir_type = mir_surface_type_satellite;
-        break;
+      impl->type_hint = hint;
+      ensure_no_surface (window);
     }
-
-  set_surface_type (GDK_MIR_WINDOW_IMPL (window->impl), mir_type);
 }
 
 static GdkWindowTypeHint
@@ -813,29 +747,7 @@ gdk_mir_window_impl_get_type_hint (GdkWindow *window)
 {
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
 
-  switch (impl->surface_type)
-    {
-      case mir_surface_type_normal:
-      case mir_surface_type_freestyle:
-      case mir_surface_type_inputmethod:
-        return GDK_WINDOW_TYPE_HINT_NORMAL;
-      case mir_surface_type_utility:
-        return GDK_WINDOW_TYPE_HINT_UTILITY;
-      case mir_surface_type_dialog:
-        return GDK_WINDOW_TYPE_HINT_DIALOG;
-      case mir_surface_type_tip:
-        return GDK_WINDOW_TYPE_HINT_TOOLTIP;
-      case mir_surface_type_menu:
-        return GDK_WINDOW_TYPE_HINT_MENU;
-      case mir_surface_type_overlay:
-        return GDK_WINDOW_TYPE_HINT_NOTIFICATION;
-      case mir_surface_type_satellite:
-        return GDK_WINDOW_TYPE_HINT_TOOLBAR;
-      case mir_surface_types:
-        break;
-    }
-
-  return GDK_WINDOW_TYPE_HINT_NORMAL;
+  return impl->type_hint;
 }
 
 void
@@ -911,64 +823,6 @@ gdk_mir_window_impl_set_transient_for (GdkWindow *window,
 
   /* Link this window to the parent */
   impl->transient_for = parent;
-  if (should_render_in_parent (window))
-    {
-      GdkMirWindowImpl *parent_impl = GDK_MIR_WINDOW_IMPL (parent->impl);
-      parent_impl->transient_children = g_list_append (parent_impl->transient_children, window);
-
-      /* Move to where the client requested */
-      window->x = impl->transient_x;
-      window->y = impl->transient_y;
-
-      /* Remove surface if we had made one before this was set */
-      ensure_no_surface (window);
-
-      /* Redraw onto parent */
-      redraw_transient (window);
-    }
-}
-
-/* TODO: Remove once we have proper transient window support. */
-GdkWindow *
-_gdk_mir_window_get_visible_transient_child (GdkWindow *window,
-                                             gdouble    x,
-                                             gdouble    y,
-                                             gdouble   *out_x,
-                                             gdouble   *out_y)
-{
-  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
-  GdkWindow *child = NULL;
-  GList *i;
-
-  x -= window->x;
-  y -= window->y;
-
-  if (x < 0 || x >= window->width || y < 0 || y >= window->height)
-    return NULL;
-
-  for (i = impl->transient_children; i && !child; i = i->next)
-    {
-      if (GDK_MIR_WINDOW_IMPL (GDK_WINDOW (i->data)->impl)->visible)
-        child = _gdk_mir_window_get_visible_transient_child (i->data, x, y, out_x, out_y);
-    }
-
-  if (child)
-    return child;
-
-  *out_x = x;
-  *out_y = y;
-
-  return window;
-}
-
-/* TODO: Remove once we have proper transient window support. */
-void
-_gdk_mir_window_transient_children_foreach (GdkWindow  *window,
-                                            void      (*func) (GdkWindow *, gpointer),
-                                            gpointer    user_data)
-{
-  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
-  g_list_foreach (impl->transient_children, (GFunc) func, user_data);
 }
 
 static void
@@ -1533,7 +1387,8 @@ _gdk_mir_window_get_dummy_egl_surface (GdkWindow *window,
       EGLNativeWindowType egl_window;
 
       display = gdk_window_get_display (window);
-      impl->dummy_surface = create_mir_surface (display, 1, 1,
+      impl->dummy_surface = create_mir_surface (display, NULL, 0, 0, 1, 1,
+                                                GDK_WINDOW_TYPE_HINT_NORMAL,
                                                 mir_buffer_usage_hardware);
 
       egl_display = _gdk_mir_display_get_egl_display (display);
-- 
2.1.4

