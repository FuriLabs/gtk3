From 52b9d12764e90efe21806a54c4191ae999ed7751 Mon Sep 17 00:00:00 2001
From: Andreas Pokorny <andreas.pokorny@canonical.com>
Date: Tue, 19 Jul 2016 14:56:34 +0200
Subject: [PATCH] Update the GDK-Mir backend to fix a few problems

See https://bugzilla.gnome.org/show_bug.cgi?id=768138
---
 configure.ac                |   2 +-
 gdk/mir/gdkmir-private.h    |   4 +-
 gdk/mir/gdkmirdisplay.c     |   2 +-
 gdk/mir/gdkmireventsource.c |  62 +++----
 gdk/mir/gdkmirscreen.c      |   4 +-
 gdk/mir/gdkmirwindowimpl.c  | 425 ++++++++++++++++++++++++++++++++++++--------
 6 files changed, 382 insertions(+), 117 deletions(-)

diff --git a/configure.ac b/configure.ac
index 89722cd..66a5fc6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -61,7 +61,7 @@ m4_define([gdk_pixbuf_required_version], [2.30.0])
 m4_define([introspection_required_version], [1.39.0])
 m4_define([wayland_required_version], [1.9.91])
 m4_define([wayland_protocols_required_version], [1.0])
-m4_define([mirclient_required_version], [0.11.0])
+m4_define([mirclient_required_version], [0.22.0])
 m4_define([mircookie_required_version], [0.17.0])
 m4_define([epoxy_required_version], [1.0])
 GLIB_REQUIRED_VERSION=glib_required_version
diff --git a/gdk/mir/gdkmir-private.h b/gdk/mir/gdkmir-private.h
index 84051a7..38f1d7a 100644
--- a/gdk/mir/gdkmir-private.h
+++ b/gdk/mir/gdkmir-private.h
@@ -83,12 +83,14 @@ GdkCursor *_gdk_mir_cursor_new_for_name (GdkDisplay *display, const gchar *name)
 
 const gchar *_gdk_mir_cursor_get_name (GdkCursor *cursor);
 
-GdkWindowImpl *_gdk_mir_window_impl_new (void);
+GdkWindowImpl *_gdk_mir_window_impl_new (GdkDisplay *display, GdkWindow *window, GdkWindowAttr *attributes, gint attributes_mask);
 
 void _gdk_mir_window_impl_set_surface_state (GdkMirWindowImpl *impl, MirSurfaceState state);
 
 void _gdk_mir_window_impl_set_surface_type (GdkMirWindowImpl *impl, MirSurfaceType type);
 
+void _gdk_mir_window_set_surface_output (GdkWindow *window, gdouble scale);
+
 void _gdk_mir_window_impl_set_cursor_state (GdkMirWindowImpl *impl, gdouble x, gdouble y, gboolean cursor_inside, guint button_state);
 
 void _gdk_mir_window_impl_get_cursor_state (GdkMirWindowImpl *impl, gdouble *x, gdouble *y, gboolean *cursor_inside, guint *button_state);
diff --git a/gdk/mir/gdkmirdisplay.c b/gdk/mir/gdkmirdisplay.c
index ffcee8a..eea892c 100644
--- a/gdk/mir/gdkmirdisplay.c
+++ b/gdk/mir/gdkmirdisplay.c
@@ -411,7 +411,7 @@ gdk_mir_display_create_window_impl (GdkDisplay    *display,
 
   if (attributes->wclass == GDK_INPUT_OUTPUT)
     {
-      window->impl = _gdk_mir_window_impl_new ();
+      window->impl = _gdk_mir_window_impl_new (display, window, attributes, attributes_mask);
       window->impl_window = window;
     }
   else /* attributes->wclass == GDK_INPUT_ONLY */
diff --git a/gdk/mir/gdkmireventsource.c b/gdk/mir/gdkmireventsource.c
index a288cb7..865b6f6 100644
--- a/gdk/mir/gdkmireventsource.c
+++ b/gdk/mir/gdkmireventsource.c
@@ -289,28 +289,17 @@ handle_key_event (GdkWindow *window, const MirInputEvent *event)
   if (!keyboard_event)
     return;
 
-  switch (mir_keyboard_event_action (keyboard_event))
-    {
-    case mir_keyboard_action_up:
-    case mir_keyboard_action_down:
-      // FIXME: Convert keycode
-      _gdk_mir_window_impl_get_cursor_state (impl, NULL, NULL, NULL, &button_state);
-      modifier_state = get_modifier_state (mir_keyboard_event_modifiers (keyboard_event), button_state);
-      keymap = gdk_keymap_get_for_display (gdk_window_get_display (window));
-
-      generate_key_event (window,
-                          mir_keyboard_event_action (keyboard_event) == mir_keyboard_action_down ? GDK_KEY_PRESS : GDK_KEY_RELEASE,
-                          modifier_state,
-                          mir_keyboard_event_key_code (keyboard_event),
-                          mir_keyboard_event_scan_code (keyboard_event),
-                          _gdk_mir_keymap_key_is_modifier (keymap, mir_keyboard_event_key_code (keyboard_event)),
-                          NANO_TO_MILLI (mir_input_event_get_event_time (event)));
-      break;
-    default:
-    //case mir_key_action_multiple:
-      // FIXME
-      break;
-    }
+  _gdk_mir_window_impl_get_cursor_state (impl, NULL, NULL, NULL, &button_state);
+  modifier_state = get_modifier_state (mir_keyboard_event_modifiers (keyboard_event), button_state);
+  keymap = gdk_keymap_get_for_display (gdk_window_get_display (window));
+
+  generate_key_event (window,
+                      mir_keyboard_event_action (keyboard_event) == mir_keyboard_action_up ? GDK_KEY_RELEASE : GDK_KEY_PRESS,
+                      modifier_state,
+                      mir_keyboard_event_key_code (keyboard_event),
+                      mir_keyboard_event_scan_code (keyboard_event),
+                      _gdk_mir_keymap_key_is_modifier (keymap, mir_keyboard_event_key_code (keyboard_event)),
+                      NANO_TO_MILLI (mir_input_event_get_event_time (event)));
 }
 
 static void
@@ -324,18 +313,13 @@ handle_touch_event (GdkWindow           *window,
 
   for (i = 0; i < n; i++)
     {
-      switch (mir_touch_event_action (mir_touch_event, i))
-        {
-        case mir_touch_action_up:
-          gdk_event = gdk_event_new (GDK_TOUCH_END);
-          break;
-        case mir_touch_action_down:
-          gdk_event = gdk_event_new (GDK_TOUCH_BEGIN);
-          break;
-        case mir_touch_action_change:
-          gdk_event = gdk_event_new (GDK_TOUCH_UPDATE);
-          break;
-        }
+      MirTouchAction action = mir_touch_event_action (mir_touch_event, i);
+      if (action == mir_touch_action_up)
+        gdk_event = gdk_event_new (GDK_TOUCH_END);
+      else if (action == mir_touch_action_down)
+        gdk_event = gdk_event_new (GDK_TOUCH_BEGIN);
+      else
+        gdk_event = gdk_event_new (GDK_TOUCH_UPDATE);
 
       gdk_event->touch.window = window;
       gdk_event->touch.sequence = GINT_TO_POINTER (mir_touch_event_id (mir_touch_event, i));
@@ -543,6 +527,13 @@ handle_close_event (GdkWindow *window)
   gdk_window_destroy_notify (window);
 }
 
+static void
+handle_surface_output_event (GdkWindow                  *window,
+                             const MirSurfaceOutputEvent *event)
+{
+  _gdk_mir_window_set_surface_output (window, mir_surface_output_event_get_scale (event));
+}
+
 typedef struct
 {
   GdkWindow *window;
@@ -597,6 +588,9 @@ gdk_mir_event_source_queue_event (GdkDisplay     *display,
     case mir_event_type_close_surface:
       handle_close_event (window);
       break;
+    case mir_event_type_surface_output:
+      handle_surface_output_event (window, mir_event_get_surface_output_event (event));
+      break;
     default:
       g_warning ("Ignoring unknown Mir event %d", mir_event_get_type (event));
       // FIXME?
diff --git a/gdk/mir/gdkmirscreen.c b/gdk/mir/gdkmirscreen.c
index 7aa0aa6..b369b03 100644
--- a/gdk/mir/gdkmirscreen.c
+++ b/gdk/mir/gdkmirscreen.c
@@ -257,7 +257,6 @@ gdk_mir_screen_get_root_window (GdkScreen *screen)
   get_screen_size (GDK_MIR_SCREEN (screen)->display_config, &width, &height);
 
   s->root_window = _gdk_display_create_window (s->display);
-  s->root_window->impl = _gdk_mir_window_impl_new ();
   s->root_window->impl_window = s->root_window;
   s->root_window->visual = s->visual;
   s->root_window->window_type = GDK_WINDOW_ROOT;
@@ -269,6 +268,7 @@ gdk_mir_screen_get_root_window (GdkScreen *screen)
   s->root_window->width = width;
   s->root_window->height = height;
   s->root_window->viewable = TRUE;
+  s->root_window->impl = _gdk_mir_window_impl_new (s->display, s->root_window, NULL, 0);
 
   return s->root_window;
 }
@@ -352,6 +352,8 @@ gdk_mir_screen_get_monitor_plug_name (GdkScreen *screen,
             return g_strdup_printf ("TV-%u", output->output_id);
           case mir_display_output_type_edp:
             return g_strdup_printf ("eDP-%u", output->output_id);
+          case mir_display_output_type_virtual:
+            return g_strdup_printf ("Virtual-%u", output->output_id);
         }
     }
 
diff --git a/gdk/mir/gdkmirwindowimpl.c b/gdk/mir/gdkmirwindowimpl.c
index 5ca9d89..fc37c7e 100644
--- a/gdk/mir/gdkmirwindowimpl.c
+++ b/gdk/mir/gdkmirwindowimpl.c
@@ -16,6 +16,7 @@
  */
 
 #include <inttypes.h>
+#include <math.h>
 
 #include "config.h"
 
@@ -28,6 +29,7 @@
 #include "gdkintl.h"
 #include "gdkdisplayprivate.h"
 #include "gdkdeviceprivate.h"
+#include "gdkframeclockprivate.h"
 
 #define GDK_MIR_WINDOW_IMPL_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_WINDOW_IMPL_MIR, GdkMirWindowImplClass))
 #define GDK_IS_WINDOW_IMPL_MIR_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_WINDOW_IMPL_MIR))
@@ -58,12 +60,21 @@ struct _GdkMirWindowImpl
   gdouble y;
   guint button_state;
 
+  GdkDisplay *display;
+
   /* Surface being rendered to (only exists when window visible) */
   MirSurface *surface;
+  MirBufferStream *buffer_stream;
+  MirBufferUsage buffer_usage;
 
   /* Cairo context for current frame */
   cairo_surface_t *cairo_surface;
 
+  gchar *title;
+
+  GdkGeometry geometry_hints;
+  GdkWindowHints geometry_mask;
+
   /* Egl surface for the current mir surface */
   EGLSurface egl_surface;
 
@@ -75,6 +86,12 @@ struct _GdkMirWindowImpl
 
   /* TRUE if cursor is inside this window */
   gboolean cursor_inside;
+
+  gboolean pending_redraw;
+  gboolean pending_commit;
+  gboolean pending_swap;
+  gboolean pending_spec_update;
+  gint output_scale;
 };
 
 struct _GdkMirWindowImplClass
@@ -85,11 +102,97 @@ struct _GdkMirWindowImplClass
 G_DEFINE_TYPE (GdkMirWindowImpl, gdk_mir_window_impl, GDK_TYPE_WINDOW_IMPL)
 
 static cairo_surface_t *gdk_mir_window_impl_ref_cairo_surface (GdkWindow *window);
+static void on_frame_clock_after_paint (GdkFrameClock *clock, GdkWindow *window);
+static void ensure_surface (GdkWindow *window);
+static void apply_geometry_hints (MirSurfaceSpec *spec, GdkMirWindowImpl *impl);
+
+static gboolean
+type_hint_differs (GdkWindowTypeHint lhs, GdkWindowTypeHint rhs)
+{
+    if (lhs == rhs)
+      return FALSE;
+
+    switch (lhs)
+    {
+      case GDK_WINDOW_TYPE_HINT_DIALOG:
+      case GDK_WINDOW_TYPE_HINT_DOCK:
+        return rhs != GDK_WINDOW_TYPE_HINT_DIALOG &&
+            rhs != GDK_WINDOW_TYPE_HINT_DOCK;
+      case GDK_WINDOW_TYPE_HINT_MENU:
+      case GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU:
+      case GDK_WINDOW_TYPE_HINT_POPUP_MENU:
+      case GDK_WINDOW_TYPE_HINT_TOOLBAR:
+      case GDK_WINDOW_TYPE_HINT_COMBO:
+        return rhs != GDK_WINDOW_TYPE_HINT_MENU &&
+            rhs != GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU &&
+            rhs != GDK_WINDOW_TYPE_HINT_POPUP_MENU &&
+            rhs != GDK_WINDOW_TYPE_HINT_TOOLBAR &&
+            rhs != GDK_WINDOW_TYPE_HINT_COMBO;
+      case GDK_WINDOW_TYPE_HINT_SPLASHSCREEN:
+      case GDK_WINDOW_TYPE_HINT_UTILITY:
+        return rhs != GDK_WINDOW_TYPE_HINT_SPLASHSCREEN &&
+            rhs != GDK_WINDOW_TYPE_HINT_UTILITY;
+      case GDK_WINDOW_TYPE_HINT_DND:
+      case GDK_WINDOW_TYPE_HINT_TOOLTIP:
+      case GDK_WINDOW_TYPE_HINT_NOTIFICATION:
+        return rhs != GDK_WINDOW_TYPE_HINT_DND &&
+            rhs != GDK_WINDOW_TYPE_HINT_TOOLTIP &&
+            rhs != GDK_WINDOW_TYPE_HINT_NOTIFICATION;
+      case GDK_WINDOW_TYPE_HINT_NORMAL:
+      case GDK_WINDOW_TYPE_HINT_DESKTOP:
+      default:
+        return rhs != GDK_WINDOW_TYPE_HINT_NORMAL &&
+            rhs != GDK_WINDOW_TYPE_HINT_DESKTOP;
+    }
+}
+
+static void
+drop_cairo_surface (GdkWindow *window)
+{
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+
+  g_clear_pointer (&impl->cairo_surface, cairo_surface_destroy);
+}
+
+static const gchar *
+get_default_title (void)
+{
+  const char *title;
+
+  title = g_get_application_name ();
+  if (!title)
+    title = g_get_prgname ();
+  if (!title)
+    title = "";
+
+  return title;
+}
 
 GdkWindowImpl *
-_gdk_mir_window_impl_new (void)
+_gdk_mir_window_impl_new (GdkDisplay *display, GdkWindow *window, GdkWindowAttr *attributes, gint attributes_mask)
 {
-  return g_object_new (GDK_TYPE_MIR_WINDOW_IMPL, NULL);
+  GdkFrameClock *frame_clock = gdk_window_get_frame_clock (window);
+  GdkMirWindowImpl *impl = g_object_new (GDK_TYPE_MIR_WINDOW_IMPL, NULL);
+
+  impl->display = display;
+
+  if (attributes && attributes_mask & GDK_WA_TITLE)
+    impl->title = g_strdup (attributes->title);
+  else
+    impl->title = g_strdup (get_default_title ());
+
+  if (attributes && attributes_mask & GDK_WA_TYPE_HINT)
+    impl->type_hint = attributes->type_hint;
+
+  impl->pending_spec_update = TRUE;
+
+  if (window->window_type != GDK_WINDOW_ROOT)
+    {
+      g_signal_connect (frame_clock, "after-paint",
+                        G_CALLBACK (on_frame_clock_after_paint), window);
+    }
+
+  return (GdkWindowImpl *) impl;
 }
 
 void
@@ -139,18 +242,25 @@ gdk_mir_window_impl_init (GdkMirWindowImpl *impl)
 {
   impl->type_hint = GDK_WINDOW_TYPE_HINT_NORMAL;
   impl->surface_state = mir_surface_state_unknown;
+  impl->output_scale = 1;
 }
 
 static void
 set_surface_state (GdkMirWindowImpl *impl,
                    MirSurfaceState state)
 {
+  MirConnection *connection = gdk_mir_display_get_mir_connection (impl->display);
   if (impl->surface_state == state)
     return;
 
   impl->surface_state = state;
-  if (impl->surface)
-    mir_surface_set_state (impl->surface, state);
+  if (impl->surface && !impl->pending_spec_update)
+    {
+      MirSurfaceSpec *spec = mir_connection_create_spec_for_changes (connection);
+      mir_surface_spec_set_state (spec, state);
+      mir_surface_apply_spec (impl->surface, spec);
+      mir_surface_spec_release (spec);
+    }
 }
 
 static void
@@ -161,26 +271,21 @@ event_cb (MirSurface     *surface,
   _gdk_mir_event_source_queue (context, event);
 }
 
-static void ensure_surface (GdkWindow *window);
-
-static MirSurface *
-create_mir_surface (GdkDisplay *display,
-                    GdkWindow *parent,
-                    gint x,
-                    gint y,
-                    gint width,
-                    gint height,
-                    GdkWindowTypeHint type,
-                    MirBufferUsage buffer_usage)
+static MirSurfaceSpec *
+create_window_type_spec (GdkDisplay *display,
+                         GdkWindow *parent,
+                         gint x,
+                         gint y,
+                         gint width,
+                         gint height,
+                         GdkWindowTypeHint type,
+                         MirBufferUsage buffer_usage)
 {
-  MirSurface *parent_surface = NULL;
-  MirSurfaceSpec *spec;
-  MirConnection *connection;
-  MirPixelFormat format;
-  MirSurface *surface;
   MirRectangle rect;
+  MirPixelFormat format;
+  MirSurface *parent_surface = NULL;
+  MirConnection *connection = gdk_mir_display_get_mir_connection (display);
 
-  connection = gdk_mir_display_get_mir_connection (display);
   format = _gdk_mir_display_get_pixel_format (display, buffer_usage);
 
   if (parent && parent->impl)
@@ -206,11 +311,10 @@ create_mir_surface (GdkDisplay *display,
     {
       case GDK_WINDOW_TYPE_HINT_DIALOG:
       case GDK_WINDOW_TYPE_HINT_DOCK:
-        spec = mir_connection_create_spec_for_dialog (connection,
+        return mir_connection_create_spec_for_dialog (connection,
                                                       width,
                                                       height,
                                                       format);
-        break;
       case GDK_WINDOW_TYPE_HINT_MENU:
       case GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU:
       case GDK_WINDOW_TYPE_HINT_POPUP_MENU:
@@ -220,22 +324,20 @@ create_mir_surface (GdkDisplay *display,
         rect.top = y;
         rect.width = 1;
         rect.height = 1;
-        spec = mir_connection_create_spec_for_menu (connection,
+        return mir_connection_create_spec_for_menu (connection,
                                                     width,
                                                     height,
                                                     format,
                                                     parent_surface,
                                                     &rect,
                                                     mir_edge_attachment_any);
-        break;
       case GDK_WINDOW_TYPE_HINT_SPLASHSCREEN:
       case GDK_WINDOW_TYPE_HINT_UTILITY:
-        spec = mir_connection_create_spec_for_modal_dialog (connection,
+        return mir_connection_create_spec_for_modal_dialog (connection,
                                                             width,
                                                             height,
                                                             format,
                                                             parent_surface);
-        break;
       case GDK_WINDOW_TYPE_HINT_DND:
       case GDK_WINDOW_TYPE_HINT_TOOLTIP:
       case GDK_WINDOW_TYPE_HINT_NOTIFICATION:
@@ -243,7 +345,7 @@ create_mir_surface (GdkDisplay *display,
         rect.top = y;
         rect.width = 1;
         rect.height = 1;
-        spec = mir_connection_create_spec_for_tooltip (connection,
+        return mir_connection_create_spec_for_tooltip (connection,
                                                        width,
                                                        height,
                                                        format,
@@ -253,19 +355,73 @@ create_mir_surface (GdkDisplay *display,
       case GDK_WINDOW_TYPE_HINT_NORMAL:
       case GDK_WINDOW_TYPE_HINT_DESKTOP:
       default:
-        spec = mir_connection_create_spec_for_normal_surface (connection,
+        return mir_connection_create_spec_for_normal_surface (connection,
                                                               width,
                                                               height,
                                                               format);
-        break;
     }
+}
 
-  mir_surface_spec_set_name (spec, g_get_prgname ());
-  mir_surface_spec_set_buffer_usage (spec, buffer_usage);
-  surface = mir_surface_create_sync (spec);
-  mir_surface_spec_release (spec);
+static void
+apply_geometry_hints (MirSurfaceSpec *spec, GdkMirWindowImpl *impl)
+{
+  if (impl->geometry_mask & GDK_HINT_RESIZE_INC)
+    {
+      mir_surface_spec_set_width_increment (spec, impl->geometry_hints.width_inc);
+      mir_surface_spec_set_height_increment (spec, impl->geometry_hints.height_inc);
+    }
+  if (impl->geometry_mask & GDK_HINT_MIN_SIZE)
+    {
+      mir_surface_spec_set_min_width (spec, impl->geometry_hints.min_width);
+      mir_surface_spec_set_min_height (spec, impl->geometry_hints.min_height);
+    }
+  if (impl->geometry_mask & GDK_HINT_MAX_SIZE)
+    {
+      mir_surface_spec_set_max_width (spec, impl->geometry_hints.max_width);
+      mir_surface_spec_set_max_height (spec, impl->geometry_hints.max_height);
+    }
+  if (impl->geometry_mask & GDK_HINT_ASPECT)
+    {
+      mir_surface_spec_set_min_aspect_ratio (spec, 1000, (unsigned)(1000.0/impl->geometry_hints.min_aspect));
+      mir_surface_spec_set_max_aspect_ratio (spec, 1000, (unsigned)(1000.0/impl->geometry_hints.max_aspect));
+    }
+}
+
+static MirSurfaceSpec*
+create_spec (GdkWindow *window, GdkMirWindowImpl *impl)
+{
+  MirSurfaceSpec *spec = NULL;
+
+  spec = create_window_type_spec (impl->display,
+                                  impl->transient_for,
+                                  impl->transient_x, impl->transient_y,
+                                  window->width, window->height,
+                                  impl->type_hint,
+                                  impl->buffer_usage);
+
+  mir_surface_spec_set_name (spec, impl->title);
+  mir_surface_spec_set_buffer_usage (spec, impl->buffer_usage);
+
+  apply_geometry_hints (spec, impl);
+
+  return spec;
+}
+
+static void
+update_surface_spec (GdkWindow *window)
+{
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+  MirSurfaceSpec *spec;
+
+  if (!impl->surface)
+    return;
+
+  spec = create_spec (window, impl);
 
-  return surface;
+  mir_surface_apply_spec (impl->surface, spec);
+  mir_surface_spec_release (spec);
+  impl->pending_spec_update = FALSE;
+  impl->buffer_stream = mir_surface_get_buffer_stream (impl->surface);
 }
 
 static GdkDevice *
@@ -319,20 +475,29 @@ ensure_surface_full (GdkWindow *window,
 {
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
   GdkMirWindowReference *window_ref;
+  MirSurfaceSpec *spec;
 
   if (impl->surface)
-    return;
+    {
+      if (impl->pending_spec_update)
+        update_surface_spec(window);
+      return;
+    }
 
   /* no destroy notify -- we must leak for now
    * https://bugs.launchpad.net/mir/+bug/1324100
    */
   window_ref = _gdk_mir_event_source_get_window_reference (window);
+  impl->buffer_usage = buffer_usage;
+
+  spec = create_spec (window, impl);
+
+  impl->surface = mir_surface_create_sync (spec);
 
-  impl->surface = create_mir_surface (gdk_window_get_display (window), impl->transient_for,
-                                      impl->transient_x, impl->transient_y,
-                                      window->width, window->height,
-                                      impl->type_hint,
-                                      buffer_usage);
+  mir_surface_spec_release(spec);
+
+  impl->pending_spec_update = FALSE;
+  impl->buffer_stream = mir_surface_get_buffer_stream (impl->surface);
 
   /* FIXME: can't make an initial resize event */
   // MirEvent *resize_event;
@@ -356,9 +521,10 @@ ensure_surface_full (GdkWindow *window,
 static void
 ensure_surface (GdkWindow *window)
 {
-  ensure_surface_full (window, window->gl_paint_context ?
-                                 mir_buffer_usage_hardware :
-                                 mir_buffer_usage_software);
+  ensure_surface_full (window,
+                       window->gl_paint_context ?
+                         mir_buffer_usage_hardware :
+                         mir_buffer_usage_software);
 }
 
 static void
@@ -390,19 +556,63 @@ ensure_no_surface (GdkWindow *window)
         }
     }
 
+  impl->pending_commit = FALSE;
+  impl->pending_swap = FALSE;
   g_clear_pointer(&impl->surface, mir_surface_release_sync);
 }
 
 static void
-send_buffer (GdkWindow *window)
+on_swap_buffer_completed (MirBufferStream *stream, void *data)
 {
+  GdkWindow *window = data;
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
 
-  /* Send the completed buffer to Mir */
-  mir_buffer_stream_swap_buffers_sync (mir_surface_get_buffer_stream (impl->surface));
-
   /* The Cairo context is no longer valid */
   g_clear_pointer (&impl->cairo_surface, cairo_surface_destroy);
+  impl->pending_swap = FALSE;
+
+  _gdk_frame_clock_thaw (gdk_window_get_frame_clock (window));
+}
+
+static void
+on_frame_clock_after_paint (GdkFrameClock *clock,
+                            GdkWindow     *window)
+{
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+
+  if (!impl->pending_commit)
+    return;
+
+  impl->pending_commit = FALSE;
+  _gdk_frame_clock_freeze (clock);
+
+  if (impl->pending_spec_update)
+    update_surface_spec (window);
+
+  impl->pending_spec_update = FALSE;
+
+  /* Send the completed buffer to Mir */
+  impl->pending_swap = TRUE;
+  mir_buffer_stream_swap_buffers (impl->buffer_stream, on_swap_buffer_completed, window);
+}
+
+static void
+send_buffer_delayed (GdkWindow *window)
+{
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+
+  if (impl->pending_swap || impl->pending_commit)
+    return;
+
+  impl->pending_commit = TRUE;
+}
+
+static void
+send_buffer (GdkWindow *window)
+{
+  send_buffer_delayed (window);
+  gdk_frame_clock_request_phase (gdk_window_get_frame_clock (window),
+                                 GDK_FRAME_CLOCK_PHASE_AFTER_PAINT);
 }
 
 static cairo_surface_t *
@@ -421,15 +631,16 @@ gdk_mir_window_impl_ref_cairo_surface (GdkWindow *window)
       return impl->cairo_surface;
     }
 
+  ensure_surface (window);
+
   /* Transient windows get rendered into a buffer and copied onto their parent */
   if (window->gl_paint_context)
     {
       cairo_surface = cairo_image_surface_create (pixel_format, window->width, window->height);
+      cairo_surface_set_device_scale (cairo_surface, (double) impl->output_scale, (double) impl->output_scale);
     }
   else if (impl->visible)
     {
-      ensure_surface (window);
-
       mir_buffer_stream_get_graphics_region (mir_surface_get_buffer_stream (impl->surface), &region);
 
       switch (region.pixel_format)
@@ -473,6 +684,7 @@ gdk_mir_window_impl_ref_cairo_surface (GdkWindow *window)
                                                            region.width,
                                                            region.height,
                                                            region.stride);
+      cairo_surface_set_device_scale (cairo_surface, (double) impl->output_scale, (double) impl->output_scale);
     }
   else
     cairo_surface = cairo_image_surface_create (pixel_format, 0, 0);
@@ -506,6 +718,7 @@ gdk_mir_window_impl_finalize (GObject *object)
 {
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (object);
 
+  g_free (impl->title);
   if (impl->background)
     cairo_pattern_destroy (impl->background);
   if (impl->surface)
@@ -526,6 +739,7 @@ gdk_mir_window_impl_show (GdkWindow *window,
   //g_printerr ("gdk_mir_window_impl_show window=%p\n", window);
 
   impl->visible = TRUE;
+  set_surface_state (impl, mir_surface_state_restored);
 
   /* Make sure there's a surface to see */
   ensure_surface (window);
@@ -547,7 +761,8 @@ gdk_mir_window_impl_hide (GdkWindow *window)
 
   impl->cursor_inside = FALSE;
   impl->visible = FALSE;
-  ensure_no_surface (window);
+
+  set_surface_state (impl, mir_surface_state_hidden);
 }
 
 static void
@@ -558,7 +773,8 @@ gdk_mir_window_impl_withdraw (GdkWindow *window)
 
   impl->cursor_inside = FALSE;
   impl->visible = FALSE;
-  ensure_no_surface (window);
+
+  set_surface_state (impl, mir_surface_state_hidden);
 }
 
 static void
@@ -610,32 +826,28 @@ gdk_mir_window_impl_move_resize (GdkWindow *window,
   g_printerr ("\n");
   */
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
-  gboolean recreate_surface = FALSE;
-
-  /* Transient windows can move wherever they want */
-  if (with_move)
-    {
-      if (x != impl->transient_x || y != impl->transient_y)
-        {
-          impl->transient_x = x;
-          impl->transient_y = y;
-          recreate_surface = TRUE;
-        }
-    }
+  //g_printerr ("gdk_mir_window_impl_move_resize window=%p, impl=%p\n", window, impl);
 
   /* If resize requested then rebuild surface */
-  if (width >= 0)
+  if (width >= 0 && (window->width != width || window->height != height))
   {
     /* We accept any resize */
     window->width = width;
     window->height = height;
-    recreate_surface = TRUE;
+    impl->pending_redraw = TRUE;
+    impl->pending_spec_update = TRUE;
   }
 
-  if (recreate_surface && impl->surface)
+  /* Transient windows can move wherever they want */
+  if (with_move)
     {
-      ensure_no_surface (window);
-      ensure_surface (window);
+      if (x != impl->transient_x || y != impl->transient_y)
+        {
+          impl->transient_x = x;
+          impl->transient_y = y;
+          if (!impl->pending_spec_update && impl->surface)
+            update_surface_spec (window);
+        }
     }
 }
 
@@ -754,9 +966,12 @@ gdk_mir_window_impl_get_device_state (GdkWindow       *window,
 static gboolean
 gdk_mir_window_impl_begin_paint (GdkWindow *window)
 {
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+
+  ensure_surface (window);
   //g_printerr ("gdk_mir_window_impl_begin_paint window=%p\n", window);
   /* Indicate we are ready to be drawn onto directly? */
-  return FALSE;
+  return impl->pending_swap;
 }
 
 static void
@@ -832,10 +1047,11 @@ gdk_mir_window_impl_set_type_hint (GdkWindow         *window,
 {
   GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
 
-  if (hint != impl->type_hint)
+  if (type_hint_differs (hint, impl->type_hint))
     {
       impl->type_hint = hint;
-      ensure_no_surface (window);
+      if (impl->surface && !impl->pending_spec_update)
+        update_surface_spec (window);
     }
 }
 
@@ -881,15 +1097,39 @@ gdk_mir_window_impl_set_geometry_hints (GdkWindow         *window,
                                         const GdkGeometry *geometry,
                                         GdkWindowHints     geom_mask)
 {
-  //g_printerr ("gdk_mir_window_impl_set_geometry_hints window=%p\n", window);
-  //FIXME: ?
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+  MirConnection *connection = gdk_mir_display_get_mir_connection (impl->display);
+  //g_printerr ("gdk_mir_window_impl_set_geometry_hints window=%p impl=%p\n", window, impl);
+
+  impl->geometry_hints = *geometry;
+  impl->geometry_mask = geom_mask;
+
+  if (impl->surface && !impl->pending_spec_update)
+    {
+       MirSurfaceSpec* spec = mir_connection_create_spec_for_changes (connection);
+       apply_geometry_hints (spec, impl);
+       mir_surface_apply_spec (impl->surface, spec);
+       mir_surface_spec_release (spec);
+    }
 }
 
 static void
 gdk_mir_window_impl_set_title (GdkWindow   *window,
                                const gchar *title)
 {
-  // g_printerr ("gdk_mir_window_impl_set_title window=%p\n", window);
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+  MirConnection *connection = gdk_mir_display_get_mir_connection (impl->display);
+  //g_printerr ("gdk_mir_window_impl_set_title window=%p\n", window);
+
+  g_free (impl->title);
+  impl->title = g_strdup (title);
+  if (impl->surface && !impl->pending_spec_update)
+    {
+       MirSurfaceSpec* spec = mir_connection_create_spec_for_changes (connection);
+       mir_surface_spec_set_name (spec, impl->title);
+       mir_surface_apply_spec (impl->surface, spec);
+       mir_surface_spec_release (spec);
+    }
 }
 
 static void
@@ -918,6 +1158,9 @@ gdk_mir_window_impl_set_transient_for (GdkWindow *window,
 
   /* Link this window to the parent */
   impl->transient_for = parent;
+
+  if (impl->surface && !impl->pending_spec_update)
+    update_surface_spec (window);
 }
 
 static void
@@ -1247,8 +1490,8 @@ static gint
 gdk_mir_window_impl_get_scale_factor (GdkWindow *window)
 {
   //g_printerr ("gdk_mir_window_impl_get_scale_factor window=%p\n", window);
-  /* Don't support monitor scaling */
-  return 1;
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+  return impl->output_scale;
 }
 
 static void
@@ -1460,7 +1703,7 @@ _gdk_mir_window_get_egl_surface (GdkWindow *window,
       ensure_surface_full (window, mir_buffer_usage_hardware);
 
       egl_display = _gdk_mir_display_get_egl_display (gdk_window_get_display (window));
-      egl_window = (EGLNativeWindowType) mir_buffer_stream_get_egl_native_window (mir_surface_get_buffer_stream (impl->surface));
+      egl_window = (EGLNativeWindowType) mir_buffer_stream_get_egl_native_window (impl->buffer_stream);
 
       impl->egl_surface =
         eglCreateWindowSurface (egl_display, config, egl_window, NULL);
@@ -1485,7 +1728,7 @@ _gdk_mir_window_get_dummy_egl_surface (GdkWindow *window,
 
       display = gdk_window_get_display (window);
       egl_display = _gdk_mir_display_get_egl_display (display);
-      egl_window = (EGLNativeWindowType) mir_buffer_stream_get_egl_native_window (mir_surface_get_buffer_stream (impl->surface));
+      egl_window = (EGLNativeWindowType) mir_buffer_stream_get_egl_native_window (impl->buffer_stream);
 
       impl->dummy_egl_surface =
         eglCreateWindowSurface (egl_display, config, egl_window, NULL);
@@ -1506,6 +1749,30 @@ gdk_mir_window_get_mir_surface (GdkWindow *window)
   return impl->surface;
 }
 
+void
+_gdk_mir_window_set_surface_output (GdkWindow *window, gdouble scale)
+{
+  // g_printerr ("_gdk_mir_window_impl_set_surface_output impl=%p\n", impl);
+  GdkMirWindowImpl *impl = GDK_MIR_WINDOW_IMPL (window->impl);
+  GdkRectangle area = {0, 0, window->width, window->height};
+  cairo_region_t *region;
+  gint new_scale = (gint) round (scale);
+
+  if (impl->output_scale != new_scale)
+    {
+      impl->output_scale = new_scale;
+
+      drop_cairo_surface (window);
+
+      if (impl->buffer_stream)
+        mir_buffer_stream_set_scale (impl->buffer_stream, (float) new_scale);
+
+      region = cairo_region_create_rectangle (&area);
+      _gdk_window_invalidate_for_expose (window, region);
+      cairo_region_destroy (region);
+    }
+}
+
 static void
 gdk_mir_window_impl_class_init (GdkMirWindowImplClass *klass)
 {
-- 
2.8.1

