From: Carlos Garnacho <carlosg@gnome.org>
Date: Thu, 18 Aug 2022 00:55:30 +0200
Subject: gtkentry: Shuffle the places doing IM reset

During entry widget manipulation (inserting or deleting text via keyboard)
the IM context is reset somewhat early, before the actual change took place.
This makes IM lag behind in terms of surrounding text and cursor position.

Shuffle these IM reset calls so that they happen after the changes, and
ensure that the IM is actually reset, since that is currently toggled on
a pretty narrow set of circumstances.

Origin: upstream, 3.24.35, commit:b0c4196f98046eb8b235240d08505680aa0e1dfb
---
 gtk/gtkentry.c | 25 +++++++++++++++++--------
 1 file changed, 17 insertions(+), 8 deletions(-)

diff --git a/gtk/gtkentry.c b/gtk/gtkentry.c
index 864c217..12974d6 100644
--- a/gtk/gtkentry.c
+++ b/gtk/gtkentry.c
@@ -4897,7 +4897,7 @@ gtk_entry_key_press (GtkWidget   *widget,
     {
       if (gtk_im_context_filter_keypress (priv->im_context, event))
 	{
-	  priv->need_im_reset = TRUE;
+	  gtk_im_context_reset (priv->im_context);
 	  retval = TRUE;
           goto out;
 	}
@@ -4939,7 +4939,7 @@ gtk_entry_key_release (GtkWidget   *widget,
     {
       if (gtk_im_context_filter_keypress (priv->im_context, event))
 	{
-	  priv->need_im_reset = TRUE;
+	  gtk_im_context_reset (priv->im_context);
 	  retval = TRUE;
           goto out;
 	}
@@ -5606,8 +5606,6 @@ gtk_entry_move_cursor (GtkEntry       *entry,
   GtkEntryPrivate *priv = entry->priv;
   gint new_pos = priv->current_pos;
 
-  gtk_entry_reset_im_context (entry);
-
   if (priv->current_pos != priv->selection_bound && !extend_selection)
     {
       /* If we have a current selection and aren't extending it, move to the
@@ -5732,6 +5730,9 @@ gtk_entry_move_cursor (GtkEntry       *entry,
     gtk_editable_set_position (GTK_EDITABLE (entry), new_pos);
   
   gtk_entry_pend_cursor_blink (entry);
+
+  priv->need_im_reset = TRUE;
+  gtk_entry_reset_im_context (entry);
 }
 
 static void
@@ -5761,8 +5762,6 @@ gtk_entry_delete_from_cursor (GtkEntry       *entry,
   gint end_pos = priv->current_pos;
   gint old_n_bytes = gtk_entry_buffer_get_bytes (get_buffer (entry));
 
-  gtk_entry_reset_im_context (entry);
-
   if (!priv->editable)
     {
       gtk_widget_error_bell (GTK_WIDGET (entry));
@@ -5772,6 +5771,8 @@ gtk_entry_delete_from_cursor (GtkEntry       *entry,
   if (priv->selection_bound != priv->current_pos)
     {
       gtk_editable_delete_selection (editable);
+      priv->need_im_reset = TRUE;
+      gtk_entry_reset_im_context (entry);
       return;
     }
   
@@ -5834,6 +5835,11 @@ gtk_entry_delete_from_cursor (GtkEntry       *entry,
 
   if (gtk_entry_buffer_get_bytes (get_buffer (entry)) == old_n_bytes)
     gtk_widget_error_bell (GTK_WIDGET (entry));
+  else
+    {
+      priv->need_im_reset = TRUE;
+      gtk_entry_reset_im_context (entry);
+    }
 
   gtk_entry_pend_cursor_blink (entry);
 }
@@ -5845,8 +5851,6 @@ gtk_entry_backspace (GtkEntry *entry)
   GtkEditable *editable = GTK_EDITABLE (entry);
   gint prev_pos;
 
-  gtk_entry_reset_im_context (entry);
-
   if (!priv->editable)
     {
       gtk_widget_error_bell (GTK_WIDGET (entry));
@@ -5856,6 +5860,8 @@ gtk_entry_backspace (GtkEntry *entry)
   if (priv->selection_bound != priv->current_pos)
     {
       gtk_editable_delete_selection (editable);
+      priv->need_im_reset = TRUE;
+      gtk_entry_reset_im_context (entry);
       return;
     }
 
@@ -5902,6 +5908,9 @@ gtk_entry_backspace (GtkEntry *entry)
           gtk_editable_delete_text (editable, prev_pos, priv->current_pos);
 	}
       
+      priv->need_im_reset = TRUE;
+      gtk_entry_reset_im_context (entry);
+
       g_free (log_attrs);
     }
   else
