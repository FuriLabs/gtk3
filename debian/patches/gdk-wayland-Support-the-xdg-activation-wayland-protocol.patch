From: Carlos Garnacho <carlosg@gnome.org>
Date: Wed, 2 Dec 2020 17:22:41 +0100
Subject: gdk/wayland: Support the xdg-activation wayland protocol

This protocol implements the IPC necessary to focus application
windows across launcher/launchee. Add support for it.

Origin: upstream, 3.24.35, commit:a79d6972e08480384993d1e2046029ef9034dded
---
 gdk/wayland/Makefile.am                   |  7 +++++
 gdk/wayland/gdkapplaunchcontext-wayland.c | 47 ++++++++++++++++++++++++++++++-
 gdk/wayland/gdkdevice-wayland.c           |  2 +-
 gdk/wayland/gdkdisplay-wayland.c          | 12 +++++++-
 gdk/wayland/gdkdisplay-wayland.h          |  3 ++
 gdk/wayland/gdkprivate-wayland.h          |  1 +
 gdk/wayland/gdkwindow-wayland.c           | 16 +++++++++--
 gdk/wayland/meson.build                   |  5 ++++
 8 files changed, 87 insertions(+), 6 deletions(-)

diff --git a/gdk/wayland/Makefile.am b/gdk/wayland/Makefile.am
index 6595013..e292a54 100644
--- a/gdk/wayland/Makefile.am
+++ b/gdk/wayland/Makefile.am
@@ -23,6 +23,8 @@ noinst_LTLIBRARIES =				\
 BUILT_SOURCES = 				\
 	pointer-gestures-unstable-v1-client-protocol.h		\
 	pointer-gestures-unstable-v1-protocol.c			\
+	xdg-activation-v1-client-protocol.h			\
+	xdg-activation-v1-protocol.c				\
 	xdg-shell-client-protocol.h				\
 	xdg-shell-protocol.c					\
 	xdg-shell-unstable-v6-client-protocol.h			\
@@ -98,6 +100,11 @@ endef
 %-client-protocol.h : $(WAYLAND_PROTOCOLS_DATADIR)/$$(call protostability,$$*)/$$(call protoname,$$*)/$$*.xml
 	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header < $< > $@
 
+xdg-activation-v1-protocol.c : $(WAYLAND_PROTOCOLS_DATADIR)/staging/xdg-activation/xdg-activation-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code < $< > $@
+xdg-activation-v1-client-protocol.h : $(WAYLAND_PROTOCOLS_DATADIR)/staging/xdg-activation/xdg-activation-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header < $< > $@
+
 %-protocol.c : $(srcdir)/protocol/%.xml
 	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code < $< > $@
 
diff --git a/gdk/wayland/gdkapplaunchcontext-wayland.c b/gdk/wayland/gdkapplaunchcontext-wayland.c
index f18c13e..004a390 100644
--- a/gdk/wayland/gdkapplaunchcontext-wayland.c
+++ b/gdk/wayland/gdkapplaunchcontext-wayland.c
@@ -30,6 +30,24 @@
 #include "gdkinternals.h"
 #include "gdkintl.h"
 
+typedef struct {
+  gchar *token;
+} AppLaunchData;
+
+static void
+token_done (gpointer                        data,
+            struct xdg_activation_token_v1 *provider,
+            const char                     *token)
+{
+  AppLaunchData *app_launch_data = data;
+
+  app_launch_data->token = g_strdup (token);
+}
+
+static const struct xdg_activation_token_v1_listener token_listener = {
+  token_done,
+};
+
 static char *
 gdk_wayland_app_launch_context_get_startup_notify_id (GAppLaunchContext *context,
                                                       GAppInfo          *info,
@@ -40,7 +58,34 @@ gdk_wayland_app_launch_context_get_startup_notify_id (GAppLaunchContext *context
 
   g_object_get (context, "display", &display, NULL);
 
-  if (display->gtk_shell_version >= 3)
+  if (display->xdg_activation)
+    {
+      struct xdg_activation_token_v1 *token;
+      GdkSeat *seat;
+      GdkWindow *focus_window;
+      AppLaunchData app_launch_data = { 0 };
+
+      seat = gdk_display_get_default_seat (GDK_DISPLAY (display));
+      focus_window = gdk_wayland_device_get_focus (gdk_seat_get_keyboard (seat));
+      token = xdg_activation_v1_get_activation_token (display->xdg_activation);
+
+      xdg_activation_token_v1_add_listener (token,
+                                            &token_listener,
+                                            &app_launch_data);
+      xdg_activation_token_v1_set_serial (token,
+                                          _gdk_wayland_seat_get_last_implicit_grab_serial (seat, NULL),
+                                          gdk_wayland_seat_get_wl_seat (seat));
+      xdg_activation_token_v1_set_surface (token,
+                                           gdk_wayland_window_get_wl_surface (focus_window));
+      xdg_activation_token_v1_commit (token);
+
+      while (app_launch_data.token == NULL)
+        wl_display_roundtrip (display->wl_display);
+
+      xdg_activation_token_v1_destroy (token);
+      id = app_launch_data.token;
+    }
+  else if (display->gtk_shell_version >= 3)
     {
       id = g_uuid_string_random ();
       gtk_shell1_notify_launch (display->gtk_shell, id);
diff --git a/gdk/wayland/gdkdevice-wayland.c b/gdk/wayland/gdkdevice-wayland.c
index a3d464b..9dc86a3 100644
--- a/gdk/wayland/gdkdevice-wayland.c
+++ b/gdk/wayland/gdkdevice-wayland.c
@@ -732,7 +732,7 @@ device_emit_grab_crossing (GdkDevice       *device,
     }
 }
 
-static GdkWindow *
+GdkWindow *
 gdk_wayland_device_get_focus (GdkDevice *device)
 {
   GdkWaylandSeat *wayland_seat = GDK_WAYLAND_SEAT (gdk_device_get_seat (device));
diff --git a/gdk/wayland/gdkdisplay-wayland.c b/gdk/wayland/gdkdisplay-wayland.c
index e91490f..7de55f7 100644
--- a/gdk/wayland/gdkdisplay-wayland.c
+++ b/gdk/wayland/gdkdisplay-wayland.c
@@ -85,6 +85,7 @@
 #define MIN_SYSTEM_BELL_DELAY_MS 20
 
 #define GTK_SHELL1_VERSION       5
+#define XDG_ACTIVATION_VERSION   1
 
 static void _gdk_wayland_display_load_cursor_theme (GdkWaylandDisplay *display_wayland);
 
@@ -519,6 +520,15 @@ gdk_registry_handle_global (void               *data,
       _gdk_wayland_screen_init_xdg_output (display_wayland->screen);
       _gdk_wayland_display_async_roundtrip (display_wayland);
     }
+  else if (strcmp (interface, "xdg_activation_v1") == 0)
+    {
+      display_wayland->xdg_activation_version =
+        MIN (version, XDG_ACTIVATION_VERSION);
+      display_wayland->xdg_activation =
+        wl_registry_bind (display_wayland->wl_registry, id,
+                          &xdg_activation_v1_interface,
+                          display_wayland->xdg_activation_version);
+    }
 
   g_hash_table_insert (display_wayland->known_globals,
                        GUINT_TO_POINTER (id), g_strdup (interface));
@@ -943,7 +953,7 @@ gdk_wayland_display_notify_startup_complete (GdkDisplay  *display,
         return;
     }
 
-  if (display_wayland->gtk_shell)
+  if (!display_wayland->xdg_activation && display_wayland->gtk_shell)
     gtk_shell1_set_startup_id (display_wayland->gtk_shell, startup_id);
 }
 
diff --git a/gdk/wayland/gdkdisplay-wayland.h b/gdk/wayland/gdkdisplay-wayland.h
index 6269630..0f66304 100644
--- a/gdk/wayland/gdkdisplay-wayland.h
+++ b/gdk/wayland/gdkdisplay-wayland.h
@@ -36,6 +36,7 @@
 #include <gdk/wayland/server-decoration-client-protocol.h>
 #include <gdk/wayland/xdg-output-unstable-v1-client-protocol.h>
 #include <gdk/wayland/primary-selection-unstable-v1-client-protocol.h>
+#include <gdk/wayland/xdg-activation-v1-client-protocol.h>
 
 #include <glib.h>
 #include <gdk/gdkkeys.h>
@@ -97,6 +98,7 @@ struct _GdkWaylandDisplay
   struct zwp_keyboard_shortcuts_inhibit_manager_v1 *keyboard_shortcuts_inhibit;
   struct org_kde_kwin_server_decoration_manager *server_decoration_manager;
   struct zxdg_output_manager_v1 *xdg_output_manager;
+  struct xdg_activation_v1 *xdg_activation;
   uint32_t xdg_output_version;
 
   GList *async_roundtrips;
@@ -125,6 +127,7 @@ struct _GdkWaylandDisplay
   int data_device_manager_version;
   int gtk_shell_version;
   int xdg_output_manager_version;
+  int xdg_activation_version;
 
   uint32_t server_decoration_mode;
 
diff --git a/gdk/wayland/gdkprivate-wayland.h b/gdk/wayland/gdkprivate-wayland.h
index 4a921b3..5173873 100644
--- a/gdk/wayland/gdkprivate-wayland.h
+++ b/gdk/wayland/gdkprivate-wayland.h
@@ -187,6 +187,7 @@ uint32_t _gdk_wayland_device_get_implicit_grab_serial(GdkWaylandDevice *device,
                                                       const GdkEvent   *event);
 uint32_t _gdk_wayland_seat_get_last_implicit_grab_serial (GdkSeat           *seat,
                                                           GdkEventSequence **seqence);
+GdkWindow * gdk_wayland_device_get_focus (GdkDevice *device);
 struct wl_data_device * gdk_wayland_device_get_data_device (GdkDevice *gdk_device);
 void gdk_wayland_seat_set_selection (GdkSeat               *seat,
                                      struct wl_data_source *source);
diff --git a/gdk/wayland/gdkwindow-wayland.c b/gdk/wayland/gdkwindow-wayland.c
index 30c0898..ed49dd6 100644
--- a/gdk/wayland/gdkwindow-wayland.c
+++ b/gdk/wayland/gdkwindow-wayland.c
@@ -3825,10 +3825,20 @@ gdk_wayland_window_focus (GdkWindow *window,
       GdkWaylandDisplay *display_wayland =
         GDK_WAYLAND_DISPLAY (gdk_window_get_display (window));
 
-      if (display_wayland->gtk_shell_version >= 3)
+      if (display_wayland->startup_notification_id)
         {
-          gtk_surface1_request_focus (impl->display_server.gtk_surface,
-                                      display_wayland->startup_notification_id);
+          if (display_wayland->xdg_activation)
+            {
+              xdg_activation_v1_activate (display_wayland->xdg_activation,
+                                          display_wayland->startup_notification_id,
+                                          impl->display_server.wl_surface);
+            }
+          else if (display_wayland->gtk_shell_version >= 3)
+            {
+              gtk_surface1_request_focus (impl->display_server.gtk_surface,
+                                          display_wayland->startup_notification_id);
+            }
+
           g_clear_pointer (&display_wayland->startup_notification_id, g_free);
         }
     }
diff --git a/gdk/wayland/meson.build b/gdk/wayland/meson.build
index e66afd7..cdc955e 100644
--- a/gdk/wayland/meson.build
+++ b/gdk/wayland/meson.build
@@ -57,6 +57,7 @@ proto_sources = [
   ['server-decoration', 'private' ],
   ['xdg-output', 'unstable', 'v1', ],
   ['primary-selection', 'unstable', 'v1', ],
+  ['xdg-activation', 'staging', 'v1', ],
 ]
 
 gdk_wayland_gen_headers = []
@@ -68,6 +69,10 @@ foreach p: proto_sources
   if proto_stability == 'stable'
     output_base = proto_name
     input = join_paths(proto_dir, '@0@/@1@/@2@.xml'.format(proto_stability, proto_name, output_base))
+  elif proto_stability == 'staging'
+    proto_version = p.get(2)
+    output_base = '@0@-@1@'.format(proto_name, proto_version)
+    input = join_paths(proto_dir, '@0@/@1@/@2@.xml'.format(proto_stability, proto_name, output_base))
   elif proto_stability == 'private'
     output_base = proto_name
     input = 'protocol/@0@.xml'.format(proto_name)
